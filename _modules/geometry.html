
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>geometry &#8212; Squid 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Squid 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for geometry</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The geometry module contains various functions aiding in euclidian manipulation</span>
<span class="sd">of atomic coordinates.</span>

<span class="sd">- :func:`align_centroid`</span>
<span class="sd">- :func:`align_frames`</span>
<span class="sd">- :func:`angle_size`</span>
<span class="sd">- :func:`array_to_atom_list`</span>
<span class="sd">- :func:`atom_list_to_array`</span>
<span class="sd">- :func:`center_frames`</span>
<span class="sd">- :func:`dihedral_angle`</span>
<span class="sd">- :func:`dist`</span>
<span class="sd">- :func:`dist_squared`</span>
<span class="sd">- :func:`get_bonds`</span>
<span class="sd">- :func:`get_angles_and_dihedrals`</span>
<span class="sd">- :func:`interpolate`</span>
<span class="sd">- :func:`motion_per_frame`</span>
<span class="sd">- :func:`mvee`</span>
<span class="sd">- :func:`orthogonal_procrustes`</span>
<span class="sd">- :func:`procrustes`</span>
<span class="sd">- :func:`rand_rotation`</span>
<span class="sd">- :func:`reduce_list`</span>
<span class="sd">- :func:`reorder_atoms_in_frames`</span>
<span class="sd">- :func:`rotate_frames`</span>
<span class="sd">- :func:`rotate_xyz`</span>
<span class="sd">- :func:`rotation_matrix`</span>
<span class="sd">- :func:`rms`</span>
<span class="sd">- :func:`smooth_xyz`</span>
<span class="sd">- :func:`translate_vector_1A`</span>
<span class="sd">- :func:`translate_vector_2B`</span>
<span class="sd">- :func:`translate_vector_3C`</span>
<span class="sd">- :func:`unwrap_molecules`</span>
<span class="sd">- :func:`unwrap_xyz`</span>

<span class="sd">------------</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># System imports</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.decomp_svd</span> <span class="k">import</span> <span class="n">svd</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">linear_sum_assignment</span>
<span class="c1"># Squid imports</span>
<span class="kn">import</span> <span class="nn">structures</span>


<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../codebase.html#geometry.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Root-Mean-Squared value of an array.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        array: *list, float*</span>
<span class="sd">            An array of floats to find the RMS of.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        rms: *float*</span>
<span class="sd">            The Root-Mean-Squared value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span></div>


<div class="viewcode-block" id="reduce_list"><a class="viewcode-back" href="../codebase.html#geometry.reduce_list">[docs]</a><span class="k">def</span> <span class="nf">reduce_list</span><span class="p">(</span><span class="n">givenList</span><span class="p">,</span> <span class="n">idfun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove duplicates of a list, whilst maintaining order.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        givenList: *list*</span>
<span class="sd">            List of anything for which __eq__ has been defined.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        cleaned_list: *list*</span>
<span class="sd">            List with duplicates removed.</span>

<span class="sd">    **References**</span>

<span class="sd">        * https://www.peterbe.com/plog/uniqifiers-benchmark</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_f10</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">idfun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to reduce_list()&quot;&quot;&quot;</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">idfun</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">idfun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">x</span>
    <span class="c1"># Order preserving</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_f10</span><span class="p">(</span><span class="n">givenList</span><span class="p">,</span> <span class="n">idfun</span><span class="p">))</span></div>


<div class="viewcode-block" id="angle_size"><a class="viewcode-back" href="../codebase.html#geometry.angle_size">[docs]</a><span class="k">def</span> <span class="nf">angle_size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the angle between three atoms.  In this case, determin the angle</span>
<span class="sd">    a-center-b.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the angle.</span>
<span class="sd">        center: :class:`structures.Atom`</span>
<span class="sd">            Center atom of the angle.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Last atom in the angle.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        theta: *float*</span>
<span class="sd">            Return the angle in degrees.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">center</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">center</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">))</span></div>


<div class="viewcode-block" id="dihedral_angle"><a class="viewcode-back" href="../codebase.html#geometry.dihedral_angle">[docs]</a><span class="k">def</span> <span class="nf">dihedral_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the Praxeolitic formula to determine the dihedral angle between</span>
<span class="sd">    4 atoms.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the dihedral.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Second atom in the dihedral.</span>
<span class="sd">        c: :class:`structures.Atom`</span>
<span class="sd">            Third atom in the dihedral.</span>
<span class="sd">        d: :class:`structures.Atom`</span>
<span class="sd">            Fourth atom in the dihedral.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        theta: *float*</span>
<span class="sd">            Return the dihedral angle in radians.</span>

<span class="sd">    **References**</span>

<span class="sd">        * http://stackoverflow.com/a/34245697</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

    <span class="n">b0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p0</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">-</span> <span class="n">p2</span>

    <span class="c1"># normalize b1 so that it does not influence magnitude of vector</span>
    <span class="c1"># rejections that come next</span>
    <span class="n">b1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

    <span class="c1"># vector rejections</span>
    <span class="c1"># v = projection of b0 onto plane perpendicular to b1</span>
    <span class="c1">#   = b0 minus component that aligns with b1</span>
    <span class="c1"># w = projection of b2 onto plane perpendicular to b1</span>
    <span class="c1">#   = b2 minus component that aligns with b1</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>

    <span class="c1"># angle between v and w in a plane is the torsion angle</span>
    <span class="c1"># v and w may not be normalized but that&#39;s fine since tan is y/x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">w</span><span class="p">)</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">phi</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_bonds"><a class="viewcode-back" href="../codebase.html#geometry.get_bonds">[docs]</a><span class="k">def</span> <span class="nf">get_bonds</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of atomic positions, determine all bonds based on proximity.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            List of atoms for which bonds are to be calculated.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        bonds: *list,* :class:`structures.Bond`</span>
<span class="sd">            Return the calculated bonds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bonds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="n">a</span><span class="o">.</span><span class="n">bonded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">dist_squared</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">dd</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">dd</span> <span class="o">&lt;</span> <span class="mf">1.2</span><span class="o">**</span><span class="mi">2</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>
                 <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&lt;</span> <span class="mf">3.1</span><span class="o">**</span><span class="mi">2</span> <span class="ow">and</span>
                       <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Pb&#39;</span><span class="p">,</span> <span class="mi">82</span><span class="p">]</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Pb&#39;</span><span class="p">,</span> <span class="mi">82</span><span class="p">]))):</span>

                <span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structures</span><span class="o">.</span><span class="n">Bond</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">dd</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">bonded</span><span class="p">:</span>
                    <span class="n">b</span><span class="o">.</span><span class="n">bonded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">bonded</span><span class="p">:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">bonded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bonds</span></div>


<div class="viewcode-block" id="get_angles_and_dihedrals"><a class="viewcode-back" href="../codebase.html#geometry.get_angles_and_dihedrals">[docs]</a><span class="k">def</span> <span class="nf">get_angles_and_dihedrals</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of atom structures with bonded information, calculate angles</span>
<span class="sd">    and dihedrals.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            List of atoms for which angles and dihedrals are to be calculated.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        angles: *list,* :class:`structures.Angle`</span>
<span class="sd">            Calculated angles.</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral`</span>
<span class="sd">            Calculated dihedrals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">center</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">bonded</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">center</span><span class="o">.</span><span class="n">bonded</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">center</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">center</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                              <span class="p">(</span><span class="n">center</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">((</span><span class="n">A</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">B</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                                      <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structures</span><span class="o">.</span><span class="n">Angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">))</span>

    <span class="c1"># Updated to provide deterministic dihedral order with the same</span>
    <span class="c1"># time complexity</span>
    <span class="n">dihedral_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dihedral_set</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">dihedral</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span> <span class="o">+</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">dihedral</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dihedral_set</span><span class="p">:</span>
                <span class="n">dihedral_set</span><span class="p">[</span><span class="n">dihedral</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">dihedral_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dihedral</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">dihedral</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">atoms</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">dihedral</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dihedral_set</span><span class="p">:</span>
                <span class="n">dihedral_set</span><span class="p">[</span><span class="n">dihedral</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">dihedral_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dihedral</span><span class="p">)</span>
    <span class="n">dihedral_list</span> <span class="o">=</span> <span class="n">reduce_list</span><span class="p">(</span><span class="n">dihedral_list</span><span class="p">)</span>
    <span class="n">dihedrals</span> <span class="o">=</span> <span class="p">[</span><span class="n">structures</span><span class="o">.</span><span class="n">Dihedral</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dihedral_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span></div>


<div class="viewcode-block" id="orthogonal_procrustes"><a class="viewcode-back" href="../codebase.html#geometry.orthogonal_procrustes">[docs]</a><span class="k">def</span> <span class="nf">orthogonal_procrustes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ref_matrix</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Using the orthogonal procrustes method, we find the unitary matrix R with</span>
<span class="sd">    det(R) &gt; 0 such that ||A*R - ref_matrix||^2 is minimized.  This varies</span>
<span class="sd">    from that within scipy by the addition of the reflection term, allowing</span>
<span class="sd">    and disallowing inversion.  NOTE - This means that the rotation matrix is</span>
<span class="sd">    used for right side multiplication!</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        A: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atoms for which R will minimize the frobenius</span>
<span class="sd">            norm ||A*R - ref_matrix||^2.</span>
<span class="sd">        ref_matrix: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atoms for which *A* is being rotated towards.</span>
<span class="sd">        reflection: *bool, optional*</span>
<span class="sd">            Whether inversion is allowed (True) or not (False).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        R: *list, list, float*</span>
<span class="sd">            Right multiplication rotation matrix to best overlay A onto the</span>
<span class="sd">            reference matrix.</span>
<span class="sd">        scale: *float*</span>
<span class="sd">            Scalar between the matrices.</span>

<span class="sd">    **Derivation**</span>

<span class="sd">        Goal: minimize ||A\*R - ref||^2, switch to trace</span>

<span class="sd">        trace((A\*R-ref).T\*(A\*R-ref)), now we distribute</span>

<span class="sd">        trace(R&#39;\*A&#39;\*A\*R) + trace(ref.T\*ref) - trace((A\*R).T\*ref) -</span>
<span class="sd">        trace(ref.T\*(A\*R)), trace doesn&#39;t care about order, so re-order</span>

<span class="sd">        trace(R\*R.T\*A.T\*A) + trace(ref.T\*ref) - trace(R.T\*A.T\*ref) -</span>
<span class="sd">        trace(ref.T\*A\*R), simplify</span>

<span class="sd">        trace(A.T\*A) + trace(ref.T\*ref) - 2\*trace(ref.T\*A\*R)</span>

<span class="sd">        Thus, to minimize we want to maximize trace(ref.T \* A \* R)</span>

<span class="sd">        u\*w\*v.T = (ref.T\*A).T</span>

<span class="sd">        ref.T \* A = w \* u.T \* v</span>

<span class="sd">        trace(ref.T \* A \* R) = trace (w \* u.T \* v \* R)</span>

<span class="sd">        differences minimized when trace(ref.T \* A \* R) is maximized, thus</span>
<span class="sd">        when trace(u.T \* v \* R) is maximized</span>

<span class="sd">        This occurs when u.T \* v \* R = I (as u, v and R are all unitary</span>
<span class="sd">        matrices so max is 1)</span>

<span class="sd">        R is a rotation matrix so R.T = R^-1</span>

<span class="sd">        u.T \* v \* I = R^-1 = R.T</span>

<span class="sd">        R = u \* v.T</span>

<span class="sd">        Thus, R = u.dot(vt)</span>


<span class="sd">    **References**</span>

<span class="sd">        * https://github.com/scipy/scipy/blob/v0.16.0/scipy/linalg/</span>
<span class="sd">          _procrustes.py#L14</span>
<span class="sd">        * http://compgroups.net/comp.soft-sys.matlab/procrustes-analysis</span>
<span class="sd">          -without-reflection/896635</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">ref_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">ref_matrix</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected ndim to be 2, but observed </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ref_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the shapes of A and ref_matrix differ (</span><span class="si">%s</span><span class="s1"> vs </span><span class="si">%s</span><span class="s1">)&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ref_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ref_matrix</span><span class="p">))</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span>  <span class="c1"># Get the rotation matrix, including reflections</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reflection</span> <span class="ow">and</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># To remove reflection, we change the sign of the rightmost column of</span>
        <span class="c1"># u (or v) and the scalar associated</span>
        <span class="c1"># with that column</span>
        <span class="n">u</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># Get the scaled difference</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">scale</span></div>


<span class="c1"># Procrustes works by geting an orthogonal frame to map frames[1:] to be as</span>
<span class="c1"># similar to frames[0] as possible. This implements the orthagonal procrustes</span>
<span class="c1"># with translation and no reflection (Partial Procrustes)</span>
<div class="viewcode-block" id="procrustes"><a class="viewcode-back" href="../codebase.html#geometry.procrustes">[docs]</a><span class="k">def</span> <span class="nf">procrustes</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">count_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append_in_loop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Propogate rotation along a list of lists of atoms to smooth out</span>
<span class="sd">    transitions between consecutive frames. This is done by rigid rotation</span>
<span class="sd">    and translation (no scaling and no inversions).  Rotation starts</span>
<span class="sd">    at frames[0].</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            List of lists of atoms.</span>
<span class="sd">        count_atoms: *list, int, optional*</span>
<span class="sd">            A list of indices for which translation and rotations will be</span>
<span class="sd">            calculated from.</span>
<span class="sd">        append_in_loop: *bool, optional*</span>
<span class="sd">            If rotation matrices for every atom (True) is desired vs rotation</span>
<span class="sd">            matrices for every frame (False). Every rotation matrix for atoms</span>
<span class="sd">            within the same frame is the same. Thus, when this is True,</span>
<span class="sd">            multiplicates will appear.</span>
<span class="sd">        reflection: *bool, optional*</span>
<span class="sd">            Whether inversion is allowed (True) or not (False).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        full_rotation: *list, list, float*</span>
<span class="sd">            List of every rotation matrix applied.  NOTE - These matrices are</span>
<span class="sd">            applied via right side multiplication.</span>

<span class="sd">    **See also**</span>

<span class="sd">        For more information, see :func:`orthogonal_procrustes`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">count_atoms</span><span class="p">:</span>
        <span class="n">count_atoms</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
        <span class="n">center_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count_atoms</span><span class="p">])</span> <span class="o">/</span>\
            <span class="nb">len</span><span class="p">(</span><span class="n">count_atoms</span><span class="p">)</span>
        <span class="n">center_y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count_atoms</span><span class="p">])</span> <span class="o">/</span>\
            <span class="nb">len</span><span class="p">(</span><span class="n">count_atoms</span><span class="p">)</span>
        <span class="n">center_z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count_atoms</span><span class="p">])</span> <span class="o">/</span>\
            <span class="nb">len</span><span class="p">(</span><span class="n">count_atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">center_x</span>
            <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">center_y</span>
            <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">-=</span> <span class="n">center_z</span>
    <span class="c1"># rotate all frames to be as similar to their neighbors as possible</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">det</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">dot</span>

    <span class="n">full_rotation</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># rotate all frames to optimal alignment</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)):</span>
        <span class="c1"># only count spring-held atoms for finding alignment</span>
        <span class="c1"># orthogonal_procrustes maps count_atoms_1 onto count_atoms_2</span>
        <span class="n">count_atoms_1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                         <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">count_atoms</span><span class="p">]</span>
        <span class="n">count_atoms_2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                         <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">count_atoms</span><span class="p">]</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">orthogonal_procrustes</span><span class="p">(</span><span class="n">count_atoms_1</span><span class="p">,</span> <span class="n">count_atoms_2</span><span class="p">,</span> <span class="n">reflection</span><span class="o">=</span><span class="n">reflection</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">det</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Procrustes returned reflection matrix&#39;</span><span class="p">)</span>
        <span class="c1"># rotate all atoms into alignment</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">dot</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="n">rotation</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;fx&#39;</span><span class="p">):</span>
                <span class="n">a</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">fz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">((</span><span class="n">a</span><span class="o">.</span><span class="n">fx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">fz</span><span class="p">),</span> <span class="n">rotation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">append_in_loop</span><span class="p">:</span>
                <span class="n">full_rotation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">append_in_loop</span><span class="p">:</span>
            <span class="n">full_rotation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full_rotation</span></div>


<div class="viewcode-block" id="interpolate"><a class="viewcode-back" href="../codebase.html#geometry.interpolate">[docs]</a><span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">frame_1</span><span class="p">,</span> <span class="n">frame_2</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linearly interpolate N frames between two given frames.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frame_1: *list,* :class:`structures.Atom`</span>
<span class="sd">            List of atoms.</span>
<span class="sd">        frame_2: *list,* :class:`structures.Atom`</span>
<span class="sd">            List of atoms.</span>
<span class="sd">        N: *int*</span>
<span class="sd">            Number of new frames you want to generate during interpolation.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list, float*</span>
<span class="sd">            List of interpolated frames (non-inclusive of frame_1 nor frame_2).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">frame_1</span><span class="p">,</span> <span class="n">frame_2</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">structures</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>
                                <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">frac</span><span class="p">,</span>
                                <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">frac</span><span class="p">,</span>
                                <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">dz</span> <span class="o">*</span> <span class="n">frac</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="motion_per_frame"><a class="viewcode-back" href="../codebase.html#geometry.motion_per_frame">[docs]</a><span class="k">def</span> <span class="nf">motion_per_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the root mean squared difference between atomic positions</span>
<span class="sd">    of adjacent frames.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            List of lists of atoms.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        motion: *list, float*</span>
<span class="sd">            List of motion between consecutive frames (frame_i vs</span>
<span class="sd">            frame_(i - 1)).  As len(motion) = len(frames), this means that</span>
<span class="sd">            motion[0] = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">per_state_avg</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">atom_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">frames</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_list</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">per_state_avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">motion</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">per_state_avg</span><span class="p">:</span>
        <span class="n">motion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">motion</span></div>


<div class="viewcode-block" id="translate_vector_1A"><a class="viewcode-back" href="../codebase.html#geometry.translate_vector_1A">[docs]</a><span class="k">def</span> <span class="nf">translate_vector_1A</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">multiple</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate x,y,z coordinates across boundary vector 1/A, as many times as</span>
<span class="sd">    &#39;multiple&#39;</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        pos: *list, float*</span>
<span class="sd">            XYZ point.</span>
<span class="sd">        multiple: *float*</span>
<span class="sd">            Scalar value to translate by. multiple = 1 means translate one</span>
<span class="sd">            full vector.</span>
<span class="sd">        system: :class:`structures.System`</span>
<span class="sd">            The system that the point is contained. The 1/A vector is pulled</span>
<span class="sd">            from the system.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        [x_a, y_a, z_a]: *list, float*</span>
<span class="sd">            New XYZ point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x_a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">xhi</span> <span class="o">-</span> <span class="n">system</span><span class="o">.</span><span class="n">xlo</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="n">y_a</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="n">z_a</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x_a</span><span class="p">,</span> <span class="n">y_a</span><span class="p">,</span> <span class="n">z_a</span><span class="p">]</span></div>


<div class="viewcode-block" id="translate_vector_2B"><a class="viewcode-back" href="../codebase.html#geometry.translate_vector_2B">[docs]</a><span class="k">def</span> <span class="nf">translate_vector_2B</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">multiple</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate x,y,z coordinates across boundary vector 2/B, as many times</span>
<span class="sd">    as &#39;multiple&#39;</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        pos: *list, float*</span>
<span class="sd">            XYZ point.</span>
<span class="sd">        multiple: *float*</span>
<span class="sd">            Scalar value to translate by. multiple = 1 means translate one</span>
<span class="sd">            full vector.</span>
<span class="sd">        system: :class:`structures.System`</span>
<span class="sd">            The system that the point is contained. The 1/A vector is pulled</span>
<span class="sd">            from the system.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        [x_b, y_b, z_b]: *list, float*</span>
<span class="sd">            New XYZ point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x_b</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">system</span><span class="o">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="n">y_b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">yhi</span> <span class="o">-</span> <span class="n">system</span><span class="o">.</span><span class="n">ylo</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="n">z_b</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x_b</span><span class="p">,</span> <span class="n">y_b</span><span class="p">,</span> <span class="n">z_b</span><span class="p">]</span></div>


<div class="viewcode-block" id="translate_vector_3C"><a class="viewcode-back" href="../codebase.html#geometry.translate_vector_3C">[docs]</a><span class="k">def</span> <span class="nf">translate_vector_3C</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">multiple</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate x,y,z coordinates across boundary vector 3/C, as many times as</span>
<span class="sd">    &#39;multiple&#39;</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        pos: *list, float*</span>
<span class="sd">            XYZ point.</span>
<span class="sd">        multiple: *float*</span>
<span class="sd">            Scalar value to translate by. multiple = 1 means translate one</span>
<span class="sd">            full vector.</span>
<span class="sd">        system: :class:`structures.System`</span>
<span class="sd">            The system that the point is contained. The 1/A vector is pulled</span>
<span class="sd">            from the system.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        [x_c, y_c, z_c]: *list, float*</span>
<span class="sd">            New XYZ point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">system</span><span class="o">.</span><span class="n">xz</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="n">y_c</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">system</span><span class="o">.</span><span class="n">yz</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="n">z_c</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">zhi</span> <span class="o">-</span> <span class="n">system</span><span class="o">.</span><span class="n">zlo</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiple</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">,</span> <span class="n">z_c</span><span class="p">]</span></div>


<div class="viewcode-block" id="dist_squared"><a class="viewcode-back" href="../codebase.html#geometry.dist_squared">[docs]</a><span class="k">def</span> <span class="nf">dist_squared</span><span class="p">(</span><span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the squared distance between two atomic species. Slightly faster than</span>
<span class="sd">    geometry.dist(a, b) as we do not take the square root.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atom1: *:class:`structures.Atom`*</span>
<span class="sd">            One of the two atoms to find the distance between.</span>
<span class="sd">        atom2: *:class:`structures.Atom`*</span>
<span class="sd">            Second of the two atoms to find the distance between.</span>
<span class="sd">        system: *:class:`structures.System`, optional*</span>
<span class="sd">            The system that the point is contained. Used for periodic distance</span>
<span class="sd">            calculations</span>

<span class="sd">    **Returns**</span>

<span class="sd">        sqr_dist: *float*</span>
<span class="sd">            Squared distance between the two atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create dummy box for all calculated distances</span>
    <span class="n">sqr_dist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Import xyz coordinates for both atoms</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">x</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">y</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">z</span>
    <span class="n">pos1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">]</span>

    <span class="n">x2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">x</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">y</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">z</span>
    <span class="n">pos2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">]</span>

    <span class="c1"># If a system is not provided, perform ordinary distance</span>
    <span class="c1"># squared calculation.</span>
    <span class="k">if</span> <span class="n">system</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate distance within one box</span>
        <span class="n">sqr_dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># If a system is provided and it is periodic, use system vectors to</span>
    <span class="c1"># determine smallest distance possible.</span>
    <span class="k">if</span> <span class="n">system</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Calculate distance within one box</span>
        <span class="n">sqr_dist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                        <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># If periodic conditions have been established, try calculating</span>
        <span class="c1"># distance between atoms that have been repeated across box</span>
        <span class="c1"># boundaries. Need to translate 26 times for a 3D space</span>
        <span class="k">if</span> <span class="n">system</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
            <span class="c1"># Iterate over -1, 0, and 1 translation for</span>
            <span class="c1"># vectors 1/A, 2/B, and 3/C</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="c1"># Translate as many times as required</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_1A</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_2B</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_3C</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>

                        <span class="c1"># Calculate new distance</span>
                        <span class="n">sqr_dist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">testPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                        <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                        <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Keep only smallest distance</span>
        <span class="n">sqr_dist</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sqr_dist</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sqr_dist</span></div>


<div class="viewcode-block" id="dist"><a class="viewcode-back" href="../codebase.html#geometry.dist">[docs]</a><span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the distance between two atomic species.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atom1: *:class:`structures.Atom`*</span>
<span class="sd">            One of the two atoms to find the distance between.</span>
<span class="sd">        atom2: *:class:`structures.Atom`*</span>
<span class="sd">            Second of the two atoms to find the distance between.</span>
<span class="sd">        system: *:class:`structures.System`, optional*</span>
<span class="sd">            The system that the point is contained. Used for periodic</span>
<span class="sd">            distance calculations</span>

<span class="sd">    **Returns**</span>

<span class="sd">        d: *float*</span>
<span class="sd">            Distance between the two atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dist_squared</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="unwrap_molecules"><a class="viewcode-back" href="../codebase.html#geometry.unwrap_molecules">[docs]</a><span class="k">def</span> <span class="nf">unwrap_molecules</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">system</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwraps the atoms in a periodic system so that no bonds are across a</span>
<span class="sd">    periodic box. Requires either (1) the atoms in the frames to have bond</span>
<span class="sd">    information, or (2) the atoms in system to have bond information. In</span>
<span class="sd">    case (2), the atoms in system serve as a template for every frame and</span>
<span class="sd">    must contain every atom.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list, list, :class:`structures.Atom`*</span>
<span class="sd">            List of lists of atoms.</span>
<span class="sd">        system: *:class:`structures.System`*</span>
<span class="sd">            The system that the point is contained. Used for periodic</span>
<span class="sd">            distance calculations</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list, :class:`structures.Atom`*</span>
<span class="sd">            Updated list of lists of atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create new flag for whether the atom has been unwrapped yet</span>
    <span class="k">for</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">atom_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="c1"># Create new flag for whether the atom has been unwrapped yet</span>
            <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span><span class="o">.</span><span class="n">unwrapped</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Rewrite original atoms contained in the frames object to have the</span>
        <span class="c1"># updated atom positions</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_list</span>

    <span class="c1"># Unwrap every atom via bond lists</span>
    <span class="k">for</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">atom_list_copy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="c1"># Unwrap all neighbots of the current atom and then recursively</span>
            <span class="c1"># continue the process for all atoms</span>
            <span class="n">atom_list</span> <span class="o">=</span> <span class="n">_unwrap_neighbors</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>

        <span class="c1"># Rewrite original atoms contained in the frames object to have the</span>
        <span class="c1"># updated atom positions</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_list</span>

    <span class="n">check_all_bonds</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">frames</span></div>


<span class="k">def</span> <span class="nf">_unwrap_neighbors</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">bond_tolerance</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add molecule index to the atom if it has not already been assigned. Then</span>
<span class="sd">    recursively pass bonded atoms to the function</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atom_list: *list, :class:`structures.Atom`*</span>
<span class="sd">            A list of atoms</span>
<span class="sd">        i_list_index: *int*</span>
<span class="sd">            The index of the atom currently being assigned. Refers to</span>
<span class="sd">            atom_list index.</span>
<span class="sd">        system: *:class:`structures.System`*</span>
<span class="sd">            The system that the point is contained. Used for periodic distance</span>
<span class="sd">            calculations</span>
<span class="sd">        bond_tolerance: *int*</span>
<span class="sd">            The tolerance for bonds being too far. The code unwraps atoms that</span>
<span class="sd">            are farther than this and are bonded</span>

<span class="sd">    **Returns**</span>

<span class="sd">        atom_list: *list, :class:`structures.Atom`*</span>
<span class="sd">            Updated list of atoms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

    <span class="c1"># If i_atom does not have any bonds, check to see if system has a reference</span>
    <span class="c1"># atoms to get bonds from</span>
    <span class="n">bond_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_atom</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bond_list</span> <span class="o">=</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">bonded</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i_atom_ref</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_atom_ref</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bond_list</span> <span class="o">=</span> <span class="n">i_atom_ref</span><span class="o">.</span><span class="n">bonded</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Check neighbors and unwrap them</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bondedAtom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bond_list</span><span class="p">):</span>
        <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

        <span class="n">j_list_index</span> <span class="o">=</span> <span class="n">bondedAtom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">j_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">]</span>

        <span class="c1"># Check if the bonded atom has already been processed</span>
        <span class="k">if</span> <span class="n">j_atom</span><span class="o">.</span><span class="n">unwrapped</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Check if distance between atoms is larger than half the box</span>
        <span class="c1"># (signifying it crossed the periodic boundary)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">i_atom</span><span class="p">,</span> <span class="n">j_atom</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">bond_tolerance</span><span class="p">:</span>
            <span class="c1"># Update the position of the bonded atom (j) so that it is the same</span>
            <span class="c1"># image as the reference atom (i). Import xyz coordinates for</span>
            <span class="c1"># both atoms</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">y</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">z</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">]</span>

            <span class="n">x2</span> <span class="o">=</span> <span class="n">j_atom</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">j_atom</span><span class="o">.</span><span class="n">y</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="n">j_atom</span><span class="o">.</span><span class="n">z</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">]</span>

            <span class="c1"># Iterate over -1, 0, and 1 translation for vectors</span>
            <span class="c1"># 1/A, 2/B, and 3/C</span>
            <span class="n">found_image</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                            <span class="k">break</span>

                        <span class="c1"># Translate as many times as required</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_1A</span><span class="p">(</span><span class="n">pos2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_2B</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
                        <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_3C</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>

                        <span class="c1"># Calculate new distance</span>
                        <span class="n">test_d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">testPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                           <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                           <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                        <span class="c1"># If test distance is less than the bond_tolerance,</span>
                        <span class="c1"># keep the translated atom position and break out of</span>
                        <span class="c1"># the loop</span>
                        <span class="k">if</span> <span class="n">test_d</span> <span class="o">&lt;</span> <span class="n">bond_tolerance</span><span class="p">:</span>
                            <span class="n">j_atom</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">j_atom</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">j_atom</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                            <span class="n">found_image</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">found_image</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find correct image&#39;</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">i_atom</span><span class="p">,</span> <span class="n">j_atom</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;current dist: </span><span class="si">%5.5f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">))</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">i_list_index</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">j_list_index</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">i_atom</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">j_atom</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">])</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">i_atom</span><span class="p">,</span> <span class="n">j_atom</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Update atom unwrapped flag</span>
        <span class="n">j_atom</span><span class="o">.</span><span class="n">unwrapped</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">atom_list</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">j_atom</span>

        <span class="c1"># Perform the same operation on the bonded atom (recursive)</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="n">_unwrap_neighbors</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">j_list_index</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">atom_list</span>


<div class="viewcode-block" id="unwrap_xyz"><a class="viewcode-back" href="../codebase.html#geometry.unwrap_xyz">[docs]</a><span class="k">def</span> <span class="nf">unwrap_xyz</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">motion_tolerance</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwraps the atoms in a periodic system so that atoms are never reflected</span>
<span class="sd">    across periodic boundary conditions. Does this by using the previous time</span>
<span class="sd">    step as the reference and undoing any periodic reflections in the</span>
<span class="sd">    lammpstrj</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list, list, :class:`structures.Atom`*</span>
<span class="sd">            List of lists of atoms.</span>
<span class="sd">        system: *:class:`structures.System`*</span>
<span class="sd">            The system that the point is contained. Used for periodic distance</span>
<span class="sd">            calculations</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list, :class:`structures.Atom`*</span>
<span class="sd">            Updated list of lists of atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Detect whether the atom has been flipped across the periodic boundary</span>
    <span class="c1"># condition (with regards to the reference atom), and unwrap the position</span>
    <span class="n">ref_atom_list</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">atom_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">for</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="n">ref_atom</span> <span class="o">=</span> <span class="n">ref_atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>
            <span class="n">cur_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

            <span class="c1"># Check if distance between atoms is larger than half the box</span>
            <span class="c1"># (signifying it crossed the periodic boundary)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">ref_atom</span><span class="p">,</span> <span class="n">cur_atom</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">motion_tolerance</span><span class="p">:</span>
                <span class="c1"># Update the position of the bonded atom (j) so that it is</span>
                <span class="c1"># the same image as the reference atom (i). Import xyz</span>
                <span class="c1"># coordinates for both atoms</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">ref_atom</span><span class="o">.</span><span class="n">x</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">ref_atom</span><span class="o">.</span><span class="n">y</span>
                <span class="n">z1</span> <span class="o">=</span> <span class="n">ref_atom</span><span class="o">.</span><span class="n">z</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">]</span>

                <span class="n">x2</span> <span class="o">=</span> <span class="n">cur_atom</span><span class="o">.</span><span class="n">x</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">cur_atom</span><span class="o">.</span><span class="n">y</span>
                <span class="n">z2</span> <span class="o">=</span> <span class="n">cur_atom</span><span class="o">.</span><span class="n">z</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">]</span>

                <span class="c1"># Iterate over -1, 0, and 1 translation for</span>
                <span class="c1"># vectors 1/A, 2/B, and 3/C</span>
                <span class="n">found_image</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">image_set</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">min_d</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">found_image</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">image_set</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                            <span class="k">break</span>

                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">image_set</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                                <span class="k">break</span>

                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">image_set</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">found_image</span><span class="p">:</span>
                                    <span class="k">break</span>

                                <span class="c1"># Translate as many times as required</span>
                                <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_1A</span><span class="p">(</span><span class="n">pos2</span><span class="p">,</span>
                                                              <span class="n">i</span><span class="p">,</span>
                                                              <span class="n">system</span><span class="p">)</span>
                                <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_2B</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span>
                                                              <span class="n">j</span><span class="p">,</span>
                                                              <span class="n">system</span><span class="p">)</span>
                                <span class="n">testPos</span> <span class="o">=</span> <span class="n">translate_vector_3C</span><span class="p">(</span><span class="n">testPos</span><span class="p">,</span>
                                                              <span class="n">k</span><span class="p">,</span>
                                                              <span class="n">system</span><span class="p">)</span>

                                <span class="c1"># Calculate new distance</span>
                                <span class="n">test_d</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">testPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                                   <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                                   <span class="p">(</span><span class="n">testPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                                <span class="c1"># Record minimum d</span>
                                <span class="k">if</span> <span class="n">test_d</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">:</span>
                                    <span class="n">min_d</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">test_d</span><span class="p">)</span>

                                <span class="c1"># If test distance is less than the</span>
                                <span class="c1"># bond_tolerance, keep the translated</span>
                                <span class="c1"># atom position and break out of the loop</span>
                                <span class="k">if</span> <span class="n">test_d</span> <span class="o">&lt;</span> <span class="n">motion_tolerance</span><span class="p">:</span>
                                    <span class="n">cur_atom</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="n">cur_atom</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="n">cur_atom</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">testPos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                                    <span class="n">found_image</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># If image not found in the small set, expand the</span>
                    <span class="c1"># image search</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_image</span><span class="p">:</span>
                        <span class="n">image_set</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">image_set</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                          <span class="nb">max</span><span class="p">(</span><span class="n">image_set</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In frame </span><span class="si">%d</span><span class="s1">, cannot find unwrapped image </span><span class="se">\</span>
<span class="s1">from images </span><span class="si">%s</span><span class="s1">. Minimum distance found: </span><span class="si">%3.5f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">frame_num</span><span class="p">,</span> <span class="n">image_set</span><span class="p">,</span> <span class="n">min_d</span><span class="p">))</span>
                            <span class="k">break</span>

                <span class="c1"># Update atom_list</span>
                <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_atom</span>

        <span class="c1"># Rewrite original atoms contained in the frames object to have the</span>
        <span class="c1"># updated atom positions</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_list</span>

        <span class="c1"># Set new reference atom_list</span>
        <span class="n">ref_atom_list</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">frame_num</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="check_all_bonds"><a class="viewcode-back" href="../codebase.html#geometry.check_all_bonds">[docs]</a><span class="k">def</span> <span class="nf">check_all_bonds</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">bond_tolerance</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add molecule index to the atom if it has not already been assigned. Then</span>
<span class="sd">    recursively pass bonded atoms to the function</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atom_list: *list*, :class:`structures.Molecule`</span>
<span class="sd">            A list of atoms</span>
<span class="sd">        i_list_index: *int*</span>
<span class="sd">            The index of the atom currently being assigned. Refers to</span>
<span class="sd">            atom_list index.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create new flag for whether the atom has been unwrapped yet</span>
    <span class="k">for</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">atom_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

            <span class="c1"># If i_atom does not have any bonds, check to see if system has a</span>
            <span class="c1"># reference atoms to get bonds from</span>
            <span class="n">bond_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_atom</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bond_list</span> <span class="o">=</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">bonded</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i_atom_ref</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_atom_ref</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">bond_list</span> <span class="o">=</span> <span class="n">i_atom_ref</span><span class="o">.</span><span class="n">bonded</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Check neighbors and unwrap them</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bondedAtom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bond_list</span><span class="p">):</span>
                <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

                <span class="n">j_list_index</span> <span class="o">=</span> <span class="n">bondedAtom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">j_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">]</span>

                <span class="c1"># Check if distance between atoms is larger than half the box</span>
                <span class="c1"># (signifying it crossed the periodic boundary)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">i_atom</span><span class="p">,</span> <span class="n">j_atom</span><span class="p">,</span> <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">bond_tolerance</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unwrapping failed. Current bond dist: </span><span class="si">%5.5f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">))</span></div>


<div class="viewcode-block" id="rotation_matrix"><a class="viewcode-back" href="../codebase.html#geometry.rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Obtain a left multiplication rotation matrix, given the axis and angle you</span>
<span class="sd">    wish to rotate by. By default it assumes units of degrees.  If theta is in</span>
<span class="sd">    radians, set units to rad.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        axis: *list, float*</span>
<span class="sd">            The axis in which to rotate around.</span>
<span class="sd">        theta: *float*</span>
<span class="sd">            The angle of rotation.</span>
<span class="sd">        units: *str, optional*</span>
<span class="sd">            The units of theta (deg or rad).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        rotatation_matrix: *list, list, float*</span>
<span class="sd">            The left multiplication rotation matrix.</span>

<span class="sd">    **References**</span>

<span class="sd">        * http://stackoverflow.com/questions/6802577/python-rotation-of-3d-vector/25709323#25709323</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;deg&quot;</span> <span class="ow">in</span> <span class="n">units</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">axis</span> <span class="o">/</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="rotate_xyz"><a class="viewcode-back" href="../codebase.html#geometry.rotate_xyz">[docs]</a><span class="k">def</span> <span class="nf">rotate_xyz</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    POTENTIALLY DEPRECATED CODE! WILL FAIL ON USE!</span>

<span class="sd">    Construct general rotation matrix using yaw, pitch, and roll</span>
<span class="sd">    (alpha, beta, gamma). Performs extrinsic rotation whose Euler angles</span>
<span class="sd">    are alpha, beta, and gamma about axes z, y, and x.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        alpha: *float*</span>
<span class="sd">            The &#39;yaw&#39; angle.</span>
<span class="sd">        beta: *float*</span>
<span class="sd">            The &#39;pitch&#39; angle.</span>
<span class="sd">        gamma: *float*</span>
<span class="sd">            The &#39;roll&#39; angle.</span>
<span class="sd">        units: *str, optional*</span>
<span class="sd">            The units of the given angles.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        rotatation_matrix: *list, list, float*</span>
<span class="sd">            The rotation matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extrinsic definition</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">matmat</span><span class="p">(</span><span class="n">matmat</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">units</span><span class="p">),</span>
                      <span class="n">rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="n">units</span><span class="p">),</span>
                      <span class="n">rotation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
                     <span class="p">)</span>
             <span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span></div>


<div class="viewcode-block" id="rotate_frames"><a class="viewcode-back" href="../codebase.html#geometry.rotate_frames">[docs]</a><span class="k">def</span> <span class="nf">rotate_frames</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span>
                  <span class="n">theta_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">theta_n</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span>
                  <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="n">cog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of atoms, generate a sequential list of rotated atomic</span>
<span class="sd">    instances.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frame: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of Atoms.</span>
<span class="sd">        theta_0: *float, optional*</span>
<span class="sd">            Starting rotation.</span>
<span class="sd">        theta_n: *float, optional*</span>
<span class="sd">            Ending rotation.</span>
<span class="sd">        dt: *float, optional*</span>
<span class="sd">            Change in rotation.</span>
<span class="sd">        axis: *list, float, optional*</span>
<span class="sd">            Which axis to rotate around.</span>
<span class="sd">        cog: *bool, optional*</span>
<span class="sd">            Whether to rotate around the center of geometry (True) or</span>
<span class="sd">            not (False).</span>
<span class="sd">        last: *bool, optional*</span>
<span class="sd">            Whether to only return the final rotation (True) or not (False).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom` *or list,* :class:`structures.Atom`</span>
<span class="sd">            Returned rotations of everything (if last is True), or just the</span>
<span class="sd">            final rotation (if last is False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frames</span><span class="p">,</span> <span class="n">image</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">]</span>
    <span class="n">natoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cog</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">translate</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">natoms</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">-=</span> <span class="n">translate</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_n</span> <span class="k">if</span> <span class="n">last</span> <span class="k">else</span> <span class="n">theta_0</span>
    <span class="k">while</span> <span class="n">theta</span> <span class="o">&lt;=</span> <span class="n">theta_n</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;deg&quot;</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">)])</span>
        <span class="n">rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cog</span><span class="p">:</span>
            <span class="n">rotated</span> <span class="o">+=</span> <span class="n">translate</span>
        <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">structures</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">rotated</span><span class="p">)])</span>
        <span class="n">theta</span> <span class="o">+=</span> <span class="n">dt</span>

    <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="rand_rotation"><a class="viewcode-back" href="../codebase.html#geometry.rand_rotation">[docs]</a><span class="k">def</span> <span class="nf">rand_rotation</span><span class="p">(</span><span class="n">limit_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">MAXITER</span><span class="o">=</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a random rotation matrix.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        limit_angle: *float, optional*</span>
<span class="sd">            Whether to confine your random rotation (in radians).</span>
<span class="sd">        lower_bound: *float, optional*</span>
<span class="sd">            A lower bound for limit_angle, at which the identity is</span>
<span class="sd">            simply returned.  This is necessary as the procedure to</span>
<span class="sd">            generate the limit_angle method is incredibly slow at</span>
<span class="sd">            small angles.</span>
<span class="sd">        MAXITER: *int, optional*</span>
<span class="sd">            A maximum iteration for when we try to calculate a rotation</span>
<span class="sd">            matrix with some limit_angle specified.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list, float*</span>
<span class="sd">            A random rotation matrix.</span>

<span class="sd">    **References**</span>

<span class="sd">        * http://tog.acm.org/resources/GraphicsGems/, Ed III</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limit_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">limit_angle</span> <span class="o">&lt;</span> <span class="n">lower_bound</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAXITER</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="c1"># Compute a vector V used for distributing points over the sphere via</span>
        <span class="c1"># the reflection I - V Transpose(V).  This formulation of V will</span>
        <span class="c1"># guarantee that if x[1] and x[2] are uniformly distributed, the</span>
        <span class="c1"># reflected points will be uniform on the sphere.  Note that V has</span>
        <span class="c1"># length sqrt(2) to eliminate the 2 in the Householder matrix.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">Vx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>
        <span class="n">Vy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span>
        <span class="n">Vz</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span>
        <span class="c1"># Compute the row vector S = Transpose(V) * R, where R is a simple</span>
        <span class="c1"># rotation by theta about the z - axis.  No need to compute Sz since</span>
        <span class="c1"># it&#39;s just Vz.</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">Sx</span> <span class="o">=</span> <span class="n">Vx</span> <span class="o">*</span> <span class="n">ct</span> <span class="o">-</span> <span class="n">Vy</span> <span class="o">*</span> <span class="n">st</span>
        <span class="n">Sy</span> <span class="o">=</span> <span class="n">Vx</span> <span class="o">*</span> <span class="n">st</span> <span class="o">+</span> <span class="n">Vy</span> <span class="o">*</span> <span class="n">ct</span>

        <span class="c1"># Construct the rotation matrix  (V Transpose(V) - I) R, which is</span>
        <span class="c1"># equivalent to V S - R.</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]</span>

        <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vx</span> <span class="o">*</span> <span class="n">Sx</span> <span class="o">-</span> <span class="n">ct</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vx</span> <span class="o">*</span> <span class="n">Sy</span> <span class="o">-</span> <span class="n">st</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vx</span> <span class="o">*</span> <span class="n">Vz</span>

        <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vy</span> <span class="o">*</span> <span class="n">Sx</span> <span class="o">+</span> <span class="n">st</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vy</span> <span class="o">*</span> <span class="n">Sy</span> <span class="o">-</span> <span class="n">ct</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vy</span> <span class="o">*</span> <span class="n">Vz</span>

        <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vz</span> <span class="o">*</span> <span class="n">Sx</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vz</span> <span class="o">*</span> <span class="n">Sy</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">z</span>   <span class="c1"># This equals Vz * Vz - 1.0</span>

        <span class="k">if</span> <span class="n">limit_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span>

        <span class="c1"># Else, we calculate the angle of rotation</span>
        <span class="c1"># https://en.wikipedia.org/wiki/Rotation_matrix,</span>
        <span class="c1">#     Tr(A) = 1 + 2 * cos(angle)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="n">limit_angle</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error in geometry.rand_rotation.  Unable to find a matrix within </span><span class="si">%d</span><span class="s2"> loops.&quot;</span> <span class="o">%</span> <span class="n">MAXITER</span><span class="p">)</span></div>


<div class="viewcode-block" id="mvee"><a class="viewcode-back" href="../codebase.html#geometry.mvee">[docs]</a><span class="k">def</span> <span class="nf">mvee</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Minimum Volume Enclosing Ellipsoid (MVEE) around atomic species.</span>
<span class="sd">    The ellipsoid is calculated for the &quot;center form&quot;: (x-c).T * A * (x-c) = 1</span>

<span class="sd">    For useful values, you can get the radii as follows:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        U, Q, V = np.linalg.svd(A)</span>
<span class="sd">        r_i = 1/sqrt(Q[i])</span>
<span class="sd">        vol = (4/3.) * pi * sqrt(1 / np.product(Q))</span>

<span class="sd">    Further, note that V is the rotation matrix giving the orientation of</span>
<span class="sd">    the ellipsoid.</span>

<span class="sd">    NOTE! You must have a minimum of 4 atoms for this to work.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        points:  *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of Atom objects.</span>
<span class="sd">        tol: *float, optional*</span>
<span class="sd">            Tolerance for ellipsoid generation.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        A: *list, list, float*</span>
<span class="sd">            Positive definite symmetric matrix of the ellipsoid&#39;s center form.</span>
<span class="sd">            This contains the ellipsoid&#39;s orientation and eccentricity.</span>
<span class="sd">        c: *list, float*</span>
<span class="sd">            Center of the ellipsoid.</span>

<span class="sd">    **References**</span>

<span class="sd">        * https://www.mathworks.com/matlabcentral/fileexchange/9542-minimum-volume-enclosing-ellipsoid?requestedDomain=www.mathworks.com</span>
<span class="sd">        * http://stackoverflow.com/questions/14016898/port-matlab-bounding-ellipsoid-code-to-python/14025140#14025140</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">points</span> <span class="o">=</span> <span class="n">structures</span><span class="o">.</span><span class="n">Molecule</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error - mvee only works on 4 or more atoms.&quot;</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Lift the dimensionality to ensure centrosymmetry</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">+</span> <span class="mf">1.0</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>  <span class="c1"># Our decision variable</span>
    <span class="k">while</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># assert p.sum() == 1 # invariant</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="o">.</span><span class="n">T</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">jdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">w_r</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w_r</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">new_p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span>  <span class="c1"># (1 - tau_r) * p_k</span>
        <span class="n">new_p</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tau</span>  <span class="c1"># tau_r * e_r</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_p</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">new_p</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">points</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">centroid</span></div>


<span class="c1"># Given a list of atom objects, this will (1) use mvee to generate a minimum</span>
<span class="c1"># centroid around the structure, and (2) rotate the ellipsoid and positions</span>
<span class="c1"># to align along the x-axis</span>
<div class="viewcode-block" id="align_centroid"><a class="viewcode-back" href="../codebase.html#geometry.align_centroid">[docs]</a><span class="k">def</span> <span class="nf">align_centroid</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">recenter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_H</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Minimum Volume Enclosing Ellipsoid (MVEE) around atomic</span>
<span class="sd">    species to align the atoms along the x-axis.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of Atom objects.</span>
<span class="sd">        recenter: *bool, optional*</span>
<span class="sd">            Whether to recenter the new coordinates around the origin or not.</span>
<span class="sd">            Note, this is done via the center of geometry, NOT the center of</span>
<span class="sd">            mass.</span>
<span class="sd">        skip_H: *bool, optional*</span>
<span class="sd">            Whether to skip hydrogen during recentering (that is, do not take</span>
<span class="sd">            them into accound when calculating the center of geometry).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        molec.atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            Rotated atomic coordinates.</span>
<span class="sd">        A: *list, list, float*</span>
<span class="sd">            Rotated positive definite symmetric matrix of the ellipsoid&#39;s</span>
<span class="sd">            center form. This contains the ellipsoid&#39;s orientation and</span>
<span class="sd">            eccentricity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># If there is only one atom here, have the centroid be a sphere.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">A</span>

    <span class="n">new_atoms</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">atoms</span><span class="p">[:])</span>

    <span class="c1"># Get points and the ellipsoid</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">centroid</span> <span class="o">=</span> <span class="n">mvee</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">structures</span><span class="o">.</span><span class="n">Molecule</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Rotate the ellipsoid</span>
    <span class="n">omega</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

    <span class="c1"># Rotate the points</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">R</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="c1"># Recenter the points</span>
    <span class="n">molec</span> <span class="o">=</span> <span class="n">structures</span><span class="o">.</span><span class="n">Molecule</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>
    <span class="n">molec</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">new_atom_list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">recenter</span><span class="p">:</span>
        <span class="n">com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">molec</span><span class="o">.</span><span class="n">get_center_of_geometry</span><span class="p">(</span><span class="n">skip_H</span><span class="o">=</span><span class="n">skip_H</span><span class="p">))</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">molec</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">com</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">molec</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">A</span></div>


<div class="viewcode-block" id="center_frames"><a class="viewcode-back" href="../codebase.html#geometry.center_frames">[docs]</a><span class="k">def</span> <span class="nf">center_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span>
                  <span class="n">ids</span><span class="p">,</span>
                  <span class="n">X_TOL</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">XY_TOL</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">Z_TOL</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">THETA_STEP</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                  <span class="n">TRANSLATE</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LEGACY CODE: Quickly and poorly implemented code.  Only use if</span>
<span class="sd">    geometry.procrustes/geometry.orthogonal_procrustes is unable to</span>
<span class="sd">    accomplish what you need.</span>

<span class="sd">    Recenter a list of lists of atomic coordinates to overlay based on input</span>
<span class="sd">    criteria.  This is a simpler method than procrustes, but will rarely</span>
<span class="sd">    minimize the frobenius norm.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            List of lists of atoms.</span>
<span class="sd">        ids: *list, int*</span>
<span class="sd">            A list of indices for the following:</span>
<span class="sd">                ids[0] - This is an atom that will be positioned at the</span>
<span class="sd">                         origin after translating the frame</span>
<span class="sd">                ids[1] - This is an atom that will lie on the positive</span>
<span class="sd">                         x-axis after two rotations of the frame</span>
<span class="sd">                ids[2] - This is an atom that will lie on the xy plane in the</span>
<span class="sd">                         positive y direction after rotation of the frame</span>
<span class="sd">        X_TOL: *float, optional*</span>
<span class="sd">            Tolerance for alignment of ids[1] along the x-axis.</span>
<span class="sd">        XY_TOL: *float, optional*</span>
<span class="sd">            Tolerance for alignment of ids[2] along the positive y-axis.</span>
<span class="sd">        Z_TOL: *float, optional*</span>
<span class="sd">            Tolerance for alignment of ids[2] along the xy plane.</span>
<span class="sd">        THETA_STEP: *float, optional*</span>
<span class="sd">            Steps at which to adjust rotation when finding optimal rotations.</span>
<span class="sd">            Smaller implies better fit to centering criteria, but slower</span>
<span class="sd">            calculations.</span>
<span class="sd">        TRANSLATE: *list, float*</span>
<span class="sd">            The desired translation from the origin.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        None</span>

<span class="sd">    **See also**</span>

<span class="sd">        For more information, see :func:`orthogonal_procrustes`</span>
<span class="sd">        and :func:`procrustes`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_pnt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">x</span>
            <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">y</span>
            <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">z</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rot_yz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fx</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">fz</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">fz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">fz</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fx</span> <span class="o">=</span> <span class="n">fx</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">=</span> <span class="n">fy</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fz</span> <span class="o">=</span> <span class="n">fz</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">rot_xy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span>
        <span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fx</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">fz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fz</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fx</span> <span class="o">=</span> <span class="n">fx</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fy</span> <span class="o">=</span> <span class="n">fy</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fz</span> <span class="o">=</span> <span class="n">fz</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">origin</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xaxis</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sqr</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># If we only have one frame, put it in a list</span>
    <span class="n">chk</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">frames</span><span class="p">]</span>
        <span class="n">chk</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Loop through frames</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
        <span class="c1"># Find the first translation to make the desired point the origin</span>
        <span class="n">trans_1</span> <span class="o">=</span> <span class="n">get_pnt</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">origin</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trans_1</span><span class="p">)):</span>
            <span class="n">trans_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Translate everything</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">trans</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">trans_1</span><span class="p">)</span>

        <span class="c1"># Find the desired x-axis&#39; rotation to place it on the xy plane</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">xaxis</span><span class="p">]</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chk</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">pnt</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Z_TOL</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">theta</span> <span class="o">+=</span> <span class="n">THETA_STEP</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot place atom of index </span><span class="si">%d</span><span class="s2"> on the xy plane&quot;</span>
                      <span class="o">%</span> <span class="n">xaxis</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try decreamath.sing THETA_STEP below </span><span class="si">%lg</span><span class="s2">...&quot;</span>
                      <span class="o">%</span> <span class="n">THETA_STEP</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="c1"># Rotate everything</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">rot_yz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Now find the angle that we rotate around the z axis to get</span>
        <span class="c1"># the +x-axis aligned</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">xaxis</span><span class="p">]</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chk_x</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">pnt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">chk</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">pnt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X_TOL</span> <span class="ow">and</span> <span class="n">chk_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">theta</span> <span class="o">+=</span> <span class="n">THETA_STEP</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot place atom of index </span><span class="si">%d</span><span class="s2"> on the x axis&quot;</span>
                      <span class="o">%</span> <span class="n">xaxis</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try decreamath.sing THETA_STEP below </span><span class="si">%lg</span><span class="s2">...&quot;</span>
                      <span class="o">%</span> <span class="n">THETA_STEP</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="c1"># Rotate everything</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">rot_xy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Now find the angle that we rotate around the x axis such that</span>
        <span class="c1"># our last vector lies on the x(+y) plane</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pnt</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">sqr</span><span class="p">]</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chk_y</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">pnt</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">chk</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">pnt</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">XY_TOL</span> <span class="ow">and</span> <span class="n">chk_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">theta</span> <span class="o">+=</span> <span class="n">THETA_STEP</span>
            <span class="k">if</span> <span class="n">theta</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot place atom of index </span><span class="si">%d</span><span class="s2"> on the x(+y) plane&quot;</span>
                      <span class="o">%</span> <span class="n">sqr</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try decreasing THETA_STEP below </span><span class="si">%lg</span><span class="s2">...&quot;</span>
                      <span class="o">%</span> <span class="n">THETA_STEP</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="c1"># Rotate everything</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">rot_yz</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

        <span class="c1"># Re-translate the whole system</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">trans</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">TRANSLATE</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Center frames has led to NaN...&quot;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">chk</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="smooth_xyz"><a class="viewcode-back" href="../codebase.html#geometry.smooth_xyz">[docs]</a><span class="k">def</span> <span class="nf">smooth_xyz</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
               <span class="n">R_MAX</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">F_MAX</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
               <span class="n">N_FRAMES</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">PROCRUSTES</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">outName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth out an xyz file by linearly interpolating frames to minimize the</span>
<span class="sd">    maximum motion between adjacent frames.  Further, this can use procrustes</span>
<span class="sd">    to best overlap adjacent frames.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        name: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            A list of lists of atoms.</span>
<span class="sd">        R_MAX: *float, optional*</span>
<span class="sd">            The maximum motion allowed between consecutive frames.</span>
<span class="sd">        F_MAX: *int, optional*</span>
<span class="sd">            The maximum number of frames allowed before failing the smooth</span>
<span class="sd">            function.</span>
<span class="sd">        N_FRAMES: *int, optional*</span>
<span class="sd">            If this is specified, forgo the R_MAX and F_MAX and just interpolate</span>
<span class="sd">            out into N_FRAMES.  Note, if more than N_FRAMES exists, this also</span>
<span class="sd">            cuts back into exactly N_FRAMES.</span>
<span class="sd">        PROCRUSTES: *bool, optional*</span>
<span class="sd">            Whether procrustes is to be used during smoothing (True), or</span>
<span class="sd">            not (False).</span>
<span class="sd">        outName: *str, optional*</span>
<span class="sd">            An output file name for the smoothed frames (without the .xyz</span>
<span class="sd">            extension).</span>
<span class="sd">        verbose: *bool, optional*</span>
<span class="sd">            Whether additional stdout is desired (True), or not (False).</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            Returns a list of smoothed frames</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get data as either frames or a file</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error - Invalid name input.  Should be either the name of an </span><span class="se">\</span>
<span class="s2">xyz file or a list: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">N_FRAMES</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R_MAX</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
        <span class="n">F_MAX</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">N_FRAMES</span> <span class="o">=</span> <span class="n">F_MAX</span>

    <span class="c1"># Loop till we&#39;re below R_MAX</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># If len(frames) &gt; N_FRAMES, break out of while and trim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N_FRAMES</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Find largest motion_per_frame</span>
        <span class="k">if</span> <span class="n">PROCRUSTES</span><span class="p">:</span>
            <span class="n">procrustes</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">motion_per_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>

        <span class="c1"># Check if we&#39;re done</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r2</span> <span class="o">&lt;</span> <span class="n">R_MAX</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">F_MAX</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------------------------------------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Error - Could not lower motion below </span><span class="si">%lg</span><span class="s2"> in </span><span class="si">%d</span><span class="s2"> frames.&quot;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">R_MAX</span><span class="p">,</span> <span class="n">F_MAX</span><span class="p">),</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Currently Frames = </span><span class="si">%d</span><span class="se">\t</span><span class="s2">r2 = </span><span class="si">%lg</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="n">r2</span><span class="p">))</span>

        <span class="c1"># Now, split the list, interpolate, and regenerate</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f_high</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="n">f_mid</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">f_low</span> <span class="o">+</span> <span class="n">f_mid</span> <span class="o">+</span> <span class="n">f_high</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f_mid</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">f_high</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f_low</span><span class="p">]</span> <span class="o">+</span> <span class="n">f_mid</span> <span class="o">+</span> <span class="n">f_high</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f_low</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f_mid</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">f_high</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">f_low</span> <span class="o">+</span> <span class="n">f_mid</span> <span class="o">+</span> <span class="p">[</span><span class="n">f_high</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Interpolated </span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2"> ... </span><span class="si">%lg</span><span class="s2">&quot;</span>
                  <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">motion_per_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">N_FRAMES</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">N_FRAMES</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N_FRAMES</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">N_FRAMES</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">mpf</span> <span class="o">=</span> <span class="n">motion_per_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">to_kill</span> <span class="o">=</span> <span class="n">mpf</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">mpf</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">del</span> <span class="n">frames</span><span class="p">[</span><span class="n">to_kill</span><span class="p">]</span>
                <span class="k">break</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N_FRAMES</span><span class="p">:</span>
        <span class="c1"># Get smallest motion and remove</span>
        <span class="k">if</span> <span class="n">PROCRUSTES</span><span class="p">:</span>
            <span class="n">procrustes</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">motion_per_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">del</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">PROCRUSTES</span><span class="p">:</span>
        <span class="n">procrustes</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">There are now a total of </span><span class="si">%d</span><span class="s2"> frames&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="align_frames"><a class="viewcode-back" href="../codebase.html#geometry.align_frames">[docs]</a><span class="k">def</span> <span class="nf">align_frames</span><span class="p">(</span><span class="n">prev_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of frames depicting some pathway, this function attempts to</span>
<span class="sd">    order atomic coordinates similarly throughout each frame.</span>

<span class="sd">    NOTE! THIS IS A VERY SIMPLE METHOD BASED ON INTERATOMIC DISTANCES!  A</span>
<span class="sd">    better procedure would be that of geometry.reorder_atoms_in_frames()</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        prev_frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            List of lists of atoms.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frames: *list, list,* :class:`structures.Atom`</span>
<span class="sd">            List of lists of atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">prev_frames</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">new_frame</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">f1</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dist_squared</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">),</span> <span class="n">a2</span><span class="p">)</span> <span class="k">for</span> <span class="n">a2</span> <span class="ow">in</span> <span class="n">f2</span> <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="n">a2</span><span class="o">.</span><span class="n">element</span><span class="p">]</span>
            <span class="n">new_frame</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_frame</span>

    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="reorder_atoms_in_frames"><a class="viewcode-back" href="../codebase.html#geometry.reorder_atoms_in_frames">[docs]</a><span class="k">def</span> <span class="nf">reorder_atoms_in_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A function to ensure that consecutive frames of an xyz file are in the</span>
<span class="sd">    same order.  This is done by minimizing the frobenious norm between</span>
<span class="sd">    consecutive frames with the application of a perterbation matrix P.</span>

<span class="sd">                      minimize ||PR_{i+1} - R_{i}||^2.</span>

<span class="sd">    This problem boils down to maximizing Tr[P R_{i + 1} R_{i}^T].  We solve</span>
<span class="sd">    this with Munkres algorithm using the scipy.optimize.linear_sum_assignment</span>
<span class="sd">    function.</span>

<span class="sd">    NOTE! This only works when we have the problem in which atom order only is</span>
<span class="sd">    mixed up.  If we also have rotations, then the problem actually becomes:</span>

<span class="sd">                      minimize ||PAR_{i+1} - R_{i}||^2</span>

<span class="sd">    Which is, unfortunately, harder as we now have two unknown</span>
<span class="sd">    matrices (P and A)!</span>

<span class="sd">    Requires scipy 0.17.0 or above.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        frames: *list,* :class:`structures.Atom`</span>
<span class="sd">            Input frames to be sorted.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        Rframes: *list,* :class:`structures.Atom`</span>
<span class="sd">            A reordered list.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frames</span>

    
    
    <span class="k">def</span> <span class="nf">sublist_reorder</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Convert types into np arrays</span>
            <span class="n">f1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">atom_list_to_array</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">f2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">atom_list_to_array</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    
            <span class="c1"># Get R_{i + 1} R_{i}^T</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># Offset by minimum so we have no negative numbers, then negate the</span>
            <span class="c1"># matrix.  This way, we are only applying a linear transformation.</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
    
            <span class="c1"># Make our Perterbation matrix</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
                <span class="n">P</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
            <span class="c1"># Apply the perterbation and continue</span>
            <span class="n">old_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="n">frames</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_to_atom_list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span> <span class="n">e2</span><span class="p">)</span>
            <span class="n">new_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span> <span class="n">f1</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
    
        <span class="k">return</span> <span class="n">frames</span>


    <span class="c1"># For each frame, sort by elements</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
        <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>

    <span class="c1"># Get a set of unique elements</span>
    <span class="n">elems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="c1"># Build up sub_lists by elements only</span>
    <span class="n">elem_lists</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">==</span> <span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span>
    <span class="p">]</span>

    <span class="c1"># For each sublist, find a perterbation matrix necessary to maximize</span>
    <span class="c1"># the trace, apply it, and return the list</span>
    <span class="n">elem_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">sublist_reorder</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">elem_lists</span><span class="p">]</span>

    <span class="c1"># Build up each frame</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">elem_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elem_lists</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frame</span>

    <span class="n">procrustes</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frames</span></div>


<div class="viewcode-block" id="atom_list_to_array"><a class="viewcode-back" href="../codebase.html#geometry.atom_list_to_array">[docs]</a><span class="k">def</span> <span class="nf">atom_list_to_array</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of atoms, return a list of coordinates.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        A: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atom objects.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        coords: *list, list, float*</span>
<span class="sd">            A list of the atomic coordinates</span>
<span class="sd">        elems: *list, str*</span>
<span class="sd">            A list of the elements associated with each index.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]),</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span></div>


<div class="viewcode-block" id="array_to_atom_list"><a class="viewcode-back" href="../codebase.html#geometry.array_to_atom_list">[docs]</a><span class="k">def</span> <span class="nf">array_to_atom_list</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">elems</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a list of atomic coordinates as lists of floats, and a list of</span>
<span class="sd">    elements, generate a list of atom objects.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        A: *list, list, float*</span>
<span class="sd">            A list of the atomic coordinates</span>
<span class="sd">        elems: *list, str*</span>
<span class="sd">            A list of the elements associated with each index.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        frame: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atom objects.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">structures</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">elems</span><span class="p">)]</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../squid.html">Squid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codebase.html">Codebase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Squid 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Henry Herbol.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>