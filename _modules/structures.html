
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>structures &#8212; Squid 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Squid 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for structures</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The Structures module contains various class objects to describe one&#39;s molecular system. </span>
<span class="sd">Each *System* object can be comprised of several *Molecule* objects which are, in turn, </span>
<span class="sd">comprised of *Atom*, *Bond*, *Angle*, *Dihedral*, and *Improper* objects.</span>

<span class="sd">- :class:`System`</span>
<span class="sd">- :class:`Molecule`</span>
<span class="sd">- :class:`Atom`</span>
<span class="sd">- :class:`Bond`</span>
<span class="sd">- :class:`Angle`</span>
<span class="sd">- :class:`Dihedral`</span>
<span class="sd">- :class:`Improper`</span>

<span class="sd">There also exists a dynamic data structure object *Struct*.</span>

<span class="sd">- :class:`Struct`</span>

<span class="sd">General atom manipulation functions that can adapted by the object classes</span>

<span class="sd">- :func:`_remove_atom_index`</span>
<span class="sd">- :func:`_remove_atom_type&#39;</span>

<span class="sd">------------</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s1">&#39;reStructuredText&#39;</span>

<span class="c1"># System imports</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="c1"># Squid imports</span>
<span class="kn">import</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">geometry</span>
<span class="kn">import</span> <span class="nn">sysconst</span>
<span class="kn">import</span> <span class="nn">files</span>
<span class="c1"># External imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="k">class</span> <span class="nc">_Physical</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of Physical is a physical object or collection of physical objects,</span>
<span class="sd">    such as a Molecule, Atom, Bond, Dihedral, System, etc.</span>
<span class="sd">    This class is designed as a parent class to Atom, Molecule, Bond, System, and</span>
<span class="sd">    Dihedral to provide a basic equals() method and other shared methods.</span>
<span class="sd">    </span>
<span class="sd">    Invariant: Everything about a _Physical instance must be described by attributes</span>
<span class="sd">    whose order does not vary or whose attributes&#39; equivalence is not defined by</span>
<span class="sd">    their order (e.g. Sets). No _Physical instance may have a 2-D list as an</span>
<span class="sd">    attribute, or equals() will fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Basic equivalence of self and other if they have the same pointer id, or if all</span>
<span class="sd">        non-callable dir entries of the two objects are equivalent.</span>

<span class="sd">        Since several parameters are not preserved between intuitively equivalent</span>
<span class="sd">        _Physical instances (e.g. Atom.index or Atom.molecule_index, Angle.theta</span>
<span class="sd">        because of how Angles are added to a System), and these must be explicitly</span>
<span class="sd">        discounted in this method.</span>
<span class="sd">        </span>
<span class="sd">        The current list of explicitly discounted parameters are:</span>
<span class="sd">        Angle.theta</span>
<span class="sd">        Atom.index</span>
<span class="sd">        Atom.molecule_index</span>
<span class="sd">        Atom.bonded&#39;s Atom identities: the number of atoms in the list is</span>
<span class="sd">        compared instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Check basic identifiers to see if the two are obviously equal or inequal</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1">#Compare all attributes of the two objects. If they are exactly identical,</span>
        <span class="c1">#Return true.</span>
        <span class="n">otherDict</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">selfDict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        
        <span class="k">if</span> <span class="n">selfDict</span> <span class="o">==</span> <span class="n">otherDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="c1">#If the two objects don&#39;t have the same attribute names, return false</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">selfDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">otherDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1">#Go through each attribute individually, and check equality. If they</span>
        <span class="c1">#are _Physical instances, use .equals() to compare.</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">selfDict</span><span class="p">:</span>
            
            <span class="c1">#Simple attribute checking</span>
            <span class="k">if</span> <span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="k">continue</span>
            
            <span class="c1">#Passed-on attributes which are not conserved between atoms</span>
            <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="s1">&#39;theta&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Angle</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="s1">&#39;index&#39;</span> <span class="ow">or</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;molecule_index&#39;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Atom</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">==</span><span class="s1">&#39;bonded&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                
            <span class="c1">#Checking _Physical attributes.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="n">_Physical</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                
                <span class="c1">#If an attribute is a list or tuple, go through it element-by-element,</span>
                <span class="c1">#assuming the order is the same between other and self, and if</span>
                <span class="c1">#any of the lists&#39;s elements are _Physical instances, compare them</span>
                <span class="c1">#with .equals()</span>
                
                <span class="c1">#Exception: If self is an Atom, do not compare the bonded lists.</span>
                <span class="c1">#This would result in an infinite loop.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">],</span><span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">],</span>
                    <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1">#print &quot;Self &quot;+ `type(selfDict[a])`+ &quot; is &quot;+`selfDict[a]`</span>
                <span class="c1">#print &quot;Other &quot; + `type(otherDict[a])`+ &quot; is &quot;+`otherDict[a]`</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">],</span><span class="n">_Physical</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">selfDict</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">otherDict</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]):</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#print &quot;False 1&quot;</span>
                            <span class="k">return</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#print &quot;False 2&quot;</span>
                        <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print &quot;False 3&quot;</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#print &quot;Passed All Check Blocks. Returning True.&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;bonded&quot;</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">text</span><span class="p">[</span><span class="s2">&quot;bonded&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot; with attributes:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<div class="viewcode-block" id="Atom"><a class="viewcode-back" href="../codebase.html#structures.Atom">[docs]</a><span class="k">class</span> <span class="nc">Atom</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A structure to hold atom information.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        element: *str*</span>
<span class="sd">            The atomic element.</span>
<span class="sd">        x: *float*</span>
<span class="sd">            The x coordinate of the atom.</span>
<span class="sd">        y: *float*</span>
<span class="sd">            The y coordinate of the atom.</span>
<span class="sd">        z: *float*</span>
<span class="sd">            The z coordinate of the atom.</span>
<span class="sd">        index: *int, optional*</span>
<span class="sd">            The atomic index within a molecule.</span>
<span class="sd">        type: *dict, optional*</span>
<span class="sd">            The forcefield type.</span>
<span class="sd">        molecule_index: *int, optional*</span>
<span class="sd">            Which molecule the atom is contained in.</span>
<span class="sd">        bonded: *list,* :class:`structures.Atom` *, optional*</span>
<span class="sd">            A list of atoms to which this atom is bonded.</span>
<span class="sd">        type_index: *int, optional*</span>
<span class="sd">            The index of the atomic type within the given forcefield.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        atom: :class:`structures.Atom`</span>
<span class="sd">            The Atom class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">molecule_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bonded</span><span class="o">=</span><span class="p">[],</span> <span class="n">type_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">=</span> <span class="n">molecule_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonded</span> <span class="o">=</span> <span class="n">bonded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_index</span> <span class="o">=</span> <span class="n">type_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">type_index</span>
        <span class="c1"># When parameterized by OPLS, &#39;type&#39; dict contains: {&#39;bond_count&#39;: 3, &#39;index&#39;: 588, &#39;notes&#39;: &#39;1,10-Phenanthroline C2&#39;, &#39;vdw_r&#39;: 3.55, &#39;element&#39;: 6, &#39;vdw_e&#39;: 0.07, &#39;charge&#39;: 0.392, &#39;mass&#39;: 12.011, &#39;index2&#39;: 48, &#39;element_name&#39;: &#39;CA&#39;}</span>
        <span class="c1"># Object May also contain lammps_type, mass, and charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>

<div class="viewcode-block" id="Atom.translate"><a class="viewcode-back" href="../codebase.html#structures.Atom.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate the atom by a vector.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            v: *list, float*</span>
<span class="sd">                A vector of 3 floats specifying the x, y, and z offsets to be applied.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Atom cannot have index &#39;None&#39;.&quot;</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, (</span><span class="si">%3.3f</span><span class="s1">, </span><span class="si">%3.3f</span><span class="s1">, </span><span class="si">%3.3f</span><span class="s1">), index: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_index</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;, type_index: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_index</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;, molecule_index: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecule_index</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;, bonded: &#39;</span>
        
        <span class="k">for</span> <span class="n">bond_atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bond_atom</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonded</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;no bonds, &#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">text</span>
    
    
<div class="viewcode-block" id="Atom.flatten"><a class="viewcode-back" href="../codebase.html#structures.Atom.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain simplified position output.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            pos: *list, float*</span>
<span class="sd">                A list holding the x, y, and z position of this atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span></div>
    
    
<div class="viewcode-block" id="Atom.set_position"><a class="viewcode-back" href="../codebase.html#structures.Atom.set_position">[docs]</a>    <span class="k">def</span> <span class="nf">set_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manually set the atomic positions by passing a tuple/list.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            pos: *list, float or tuple, float*</span>
<span class="sd">                A vector of 3 floats specifying the new x, y, and z coordinate.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>
    
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_string</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bond"><a class="viewcode-back" href="../codebase.html#structures.Bond">[docs]</a><span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A structure to hold bond information.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the bond.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Second atom in the bond.</span>
<span class="sd">        type: *dict, optional*</span>
<span class="sd">            The forcefield type.</span>
<span class="sd">        r: *float, optional*</span>
<span class="sd">            The bond length.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        bond: :class:`structures.Bond`</span>
<span class="sd">            The Bond class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Angle"><a class="viewcode-back" href="../codebase.html#structures.Angle">[docs]</a><span class="k">class</span> <span class="nc">Angle</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A structure to hold angle information.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the angle.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Second atom in the angle.</span>
<span class="sd">        c: :class:`structures.Atom`</span>
<span class="sd">            Third atom in the angle.</span>
<span class="sd">        type: *dict, optional*</span>
<span class="sd">            The forcefield type.</span>
<span class="sd">        theta: *float, optional*</span>
<span class="sd">            The angle.</span>


<span class="sd">    **Returns**</span>

<span class="sd">        angle: :class:`structures.Angle`</span>
<span class="sd">            The Angle class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span>
        
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot; with attributes:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dihedral"><a class="viewcode-back" href="../codebase.html#structures.Dihedral">[docs]</a><span class="k">class</span> <span class="nc">Dihedral</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A structure to hold dihedral information.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the dihedral.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Second atom in the dihedral.</span>
<span class="sd">        c: :class:`structures.Atom`</span>
<span class="sd">            Third atom in the dihedral.</span>
<span class="sd">        d: :class:`structures.Atom`</span>
<span class="sd">            Fourth atom in the dihedral.</span>
<span class="sd">        type: *dict, optional*</span>
<span class="sd">            The forcefield type.</span>
<span class="sd">        theta: *float, optional*</span>
<span class="sd">            The dihedral angle.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        dihedral: :class:`structures.Dihedral`</span>
<span class="sd">            The Dihedral class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="Improper"><a class="viewcode-back" href="../codebase.html#structures.Improper">[docs]</a><span class="k">class</span> <span class="nc">Improper</span><span class="p">(</span><span class="n">Dihedral</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A structure to hold improper information.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        a: :class:`structures.Atom`</span>
<span class="sd">            First atom in the improper.</span>
<span class="sd">        b: :class:`structures.Atom`</span>
<span class="sd">            Second atom in the improper.</span>
<span class="sd">        c: :class:`structures.Atom`</span>
<span class="sd">            Third atom in the improper.</span>
<span class="sd">        d: :class:`structures.Atom`</span>
<span class="sd">            Fourth atom in the improper.</span>
<span class="sd">        type: *dict, optional*</span>
<span class="sd">            The forcefield type.</span>
<span class="sd">        theta: *float, optional*</span>
<span class="sd">            The improper angle.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        improper: :class:`structures.Improper`</span>
<span class="sd">            The Improper class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../codebase.html#structures.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A molecule object to store atoms and any/all associated interatomic connections.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms_or_filename: *list,* :class:`structures.Atom` *or str*</span>
<span class="sd">            Either (a) a list of atoms or (b) a string pointing to a cml file containing the atoms.</span>
<span class="sd">        bonds: *list,* :class:`structures.Bond` *, optional*</span>
<span class="sd">            A list of all bonds within the system.</span>
<span class="sd">        angles: *list,* :class:`structures.Angle` *, optional*</span>
<span class="sd">            A list of all angles within the system.</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral` *, optional*</span>
<span class="sd">            A list of all dihedrals within the system.</span>
<span class="sd">        parameter_file: *str, optional*</span>
<span class="sd">            A path to your forcefield file. Currently only supports OPLS-AA.</span>
<span class="sd">        extra_parameters: *dict, optional*</span>
<span class="sd">            Additional OPLS parameters to apply to the forcefield.</span>
<span class="sd">        test_charges: *bool, optional*</span>
<span class="sd">            Bypass inconsistencies in molecular charge (False) or throw errors when inconsistencies exist (True).</span>
<span class="sd">        allow_errors: *bool, optional*</span>
<span class="sd">            Permit constructions of ill-conditioned molecules, such as empty bonds (True), or throw errors (False).</span>
<span class="sd">        default_angles: *dict, optional*</span>
<span class="sd">            A default forcefield angle type to be set if angle types are set to None.</span>
<span class="sd">        test_consistency: *bool, optional*</span>
<span class="sd">            Whether to validate the input cml file against OPLS.</span>
<span class="sd">        charge: *float, optional*</span>
<span class="sd">            The total charge of this molecule.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        molecule: :class:`structures.Molecule`</span>
<span class="sd">            The Molecule class container.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_or_filename</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
     <span class="n">dihedrals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameter_file</span><span class="o">=</span><span class="n">sysconst</span><span class="o">.</span><span class="n">opls_path</span><span class="p">,</span> <span class="n">extra_parameters</span><span class="o">=</span><span class="p">{},</span>
     <span class="n">test_charges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
     <span class="n">test_consistency</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
        <span class="c1"># Set atoms, bonds, etc, or assume &#39;atoms&#39; contains all those things if only one parameter is passed in</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">atoms_or_filename</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">atoms_or_filename</span>

            <span class="c1"># Check file type and import using appropriate method. Default is to assume it is a cml</span>
            <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span>
                <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">read_lammps_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">read_cml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                     <span class="n">parameter_file</span><span class="o">=</span><span class="n">parameter_file</span><span class="p">,</span>
                     <span class="n">extra_parameters</span><span class="o">=</span><span class="n">extra_parameters</span><span class="p">,</span>
                     <span class="n">test_charges</span><span class="o">=</span><span class="n">test_charges</span><span class="p">,</span>
                     <span class="n">allow_errors</span><span class="o">=</span><span class="n">allow_errors</span><span class="p">,</span>
                     <span class="n">default_angles</span><span class="o">=</span><span class="n">default_angles</span><span class="p">,</span>
                     <span class="n">test_consistency</span><span class="o">=</span><span class="n">test_consistency</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bonds</span> <span class="ow">and</span> <span class="n">angles</span> <span class="ow">and</span> <span class="n">dihedrals</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">atoms_or_filename</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span>
        <span class="k">elif</span> <span class="n">bonds</span> <span class="ow">and</span> <span class="n">angles</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">atoms_or_filename</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">atoms_or_filename</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">atoms_or_filename</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="n">bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">dihedrals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">charge</span>

<div class="viewcode-block" id="Molecule.set_types"><a class="viewcode-back" href="../codebase.html#structures.Molecule.set_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">P</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This will, using a parameter object, assign a pointer of which type</span>
<span class="sd">        corresponds with each atom, bond, angle, and dihedral.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            P: :class:`squid.ff_params.Parameters`</span>
<span class="sd">                A general parameter object</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="o">.</span><span class="n">coul_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)),</span> <span class="n">P</span><span class="o">.</span><span class="n">lj_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">))]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">coul_type</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">coul_params</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">lj_type</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">lj_params</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">opls_structure_dict</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">bond_params</span><span class="p">,</span> <span class="s2">&quot;Non-OPLS Bond was defined!  Likely an error in typing OPLS parameters, or within your CML files.&quot;</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">bond_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">bond_params</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">opls_structure_dict</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">angle_params</span><span class="p">,</span> <span class="s2">&quot;Non-OPLS Angle was defined!  Likely an error in typing OPLS parameters, or within your CML files.&quot;</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">angle_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">angle_params</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">opls_structure_dict</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">dihedral_params</span><span class="p">,</span> <span class="s2">&quot;Non-OPLS Dihedral was defined!  Likely an error in typing OPLS parameters, or within your CML files.&quot;</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dihedral_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dihedral_params</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Molecule.flatten"><a class="viewcode-back" href="../codebase.html#structures.Molecule.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flatten out all atoms into a 1D array.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            atoms: *list, float*</span>
<span class="sd">                A 1D array of atomic positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">net_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">charge</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">charges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not all charges set.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">charges</span><span class="p">)</span>

<div class="viewcode-block" id="Molecule.rotate"><a class="viewcode-back" href="../codebase.html#structures.Molecule.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate the molecule by the given matrix *m*.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            m: *list, list, float*</span>
<span class="sd">                A 3x3 matrix describing the rotation to be applied to this molecule.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span><span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">]))</span></div>
    
<div class="viewcode-block" id="Molecule.rand_rotate"><a class="viewcode-back" href="../codebase.html#structures.Molecule.rand_rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rand_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center_of_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly rotate a molecule.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            in_place: *bool, optional*</span>
<span class="sd">                Whether to rotate randomly (False), or around the molecule&#39;s center of mass (True).</span>
<span class="sd">            limit_angle: *float, optional*</span>
<span class="sd">                Whether to confine your random rotation (in radians).</span>
<span class="sd">            center_of_geometry: *bool, optional*</span>
<span class="sd">                Whether to rotate around the center of geometry (True) or mass (False).</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rand_m</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">rand_rotation</span><span class="p">(</span><span class="n">limit_angle</span><span class="o">=</span><span class="n">limit_angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">center_of_geometry</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_geometry</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_center</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rand_m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">center</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.perturbate"><a class="viewcode-back" href="../codebase.html#structures.Molecule.perturbate">[docs]</a>    <span class="k">def</span> <span class="nf">perturbate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">center_of_geometry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly perturbate atomic coordinates, and apply a slight rotation.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            dx: *float, optional*</span>
<span class="sd">                By how much you are willing to perturbate via translation.</span>
<span class="sd">            dr: *float, optional*</span>
<span class="sd">                By how much you are willing to perturbate via rotation in degrees.</span>
<span class="sd">            center_of_geometry: *bool, optional*</span>
<span class="sd">                Whether to do the random rotation by the center of geometry (True) or mass (False).</span>
<span class="sd">                Note, if types are not set, it will fail in the case of center of mass.</span>
<span class="sd">            rotate: *bool, optional*</span>
<span class="sd">                Whether to randomly rotate the molecule or not.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">rand_step</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">dx</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">a</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">rand_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rotate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rand_rotate</span><span class="p">(</span><span class="n">limit_angle</span><span class="o">=</span><span class="n">dr</span><span class="p">,</span> <span class="n">center_of_geometry</span><span class="o">=</span><span class="n">center_of_geometry</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.translate"><a class="viewcode-back" href="../codebase.html#structures.Molecule.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a translation to this molecule.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            v: *list, float*</span>
<span class="sd">                A list of 3 elements: the x, y, and z translations to be applied.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="o">+=</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Molecule.set_positions"><a class="viewcode-back" href="../codebase.html#structures.Molecule.set_positions">[docs]</a>    <span class="k">def</span> <span class="nf">set_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">new_atom_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manually specify atomic positions of your molecule.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            positions: *list, float*</span>
<span class="sd">                A list, either 2D or 1D, of the atomic positions.  Note, this should</span>
<span class="sd">                be in the same order that the atoms are stored in.</span>

<span class="sd">            new_atom_list: *bool, optional*</span>
<span class="sd">                Whether to generate an entirely new atom list (True) or re-write atom</span>
<span class="sd">                positions of those atoms already stored (False). Note, if a new list</span>
<span class="sd">                is written, connections (bonds, angles, ...) are not changed.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">new_atom_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;position list does not hold the same number of atoms as does this molecule. Consider raising new_atom_list flag in set_positions.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_atom_list</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
                <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="Molecule.get_center_of_geometry"><a class="viewcode-back" href="../codebase.html#structures.Molecule.get_center_of_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">get_center_of_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_H</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the center of geometry of the molecule.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            skip_H: *bool, optional*</span>
<span class="sd">                Whether to include Hydrogens in the calculation (False), or not (True).</span>

<span class="sd">        **Returns**</span>

<span class="sd">            cog: *tuple, float*</span>
<span class="sd">                A tuple of the x, y, and z coordinate of the center of geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_H</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">skip_H</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="o">!=</span> <span class="s2">&quot;H&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.get_center_of_mass"><a class="viewcode-back" href="../codebase.html#structures.Molecule.get_center_of_mass">[docs]</a>    <span class="k">def</span> <span class="nf">get_center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the center of mass of the molecule.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            com: *list, float*</span>
<span class="sd">                A list of the x, y, and z coordinate of the center of mass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">yList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">totalMass</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">xList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
            <span class="n">yList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
            <span class="n">zList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
            <span class="n">totalMass</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">xList</span><span class="p">)</span> <span class="o">/</span> <span class="n">totalMass</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">yList</span><span class="p">)</span> <span class="o">/</span> <span class="n">totalMass</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">zList</span><span class="p">)</span> <span class="o">/</span> <span class="n">totalMass</span><span class="p">]</span></div>

<div class="viewcode-block" id="Molecule.set_center"><a class="viewcode-back" href="../codebase.html#structures.Molecule.set_center">[docs]</a>    <span class="k">def</span> <span class="nf">set_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recenter the molecule to the origin.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            xyz: *list, float, optional*</span>
<span class="sd">                A list of x, y, and z offsets to be applied post centering.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if mass information available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_mass</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_center_of_geometry</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Molecule.remove_atom_index"><a class="viewcode-back" href="../codebase.html#structures.Molecule.remove_atom_index">[docs]</a>    <span class="k">def</span> <span class="nf">remove_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes selected indices from system. Does so by compiling new lists for atoms, bonds, angles, and dihedrals. Will be faster than Remove in cases</span>
<span class="sd">        where you are only keeping a few atoms.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            type_indices: *list, int, optional*</span>
<span class="sd">                A list of OPLS types.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">_remove_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.remove_atom_type"><a class="viewcode-back" href="../codebase.html#structures.Molecule.remove_atom_type">[docs]</a>    <span class="k">def</span> <span class="nf">remove_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes selected OPLS types from system. Does so by compiling new lists for atoms, bonds, angles, and dihedrals. Will be faster than Remove in cases</span>
<span class="sd">        where you are only keeping a few atoms.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            type_indices: *list, int, optional*</span>
<span class="sd">                A list of OPLS types.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">_remove_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span> <span class="n">type_indices</span><span class="o">=</span><span class="n">type_indices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.merge"><a class="viewcode-back" href="../codebase.html#structures.Molecule.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function merges another molecule into this one, offsetting indices as needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angles</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">dihedrals</span></div>

    <span class="c1"># When printing molecule, print all atoms</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="n">atom</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">text</span></div>

<div class="viewcode-block" id="System"><a class="viewcode-back" href="../codebase.html#structures.System">[docs]</a><span class="k">class</span> <span class="nc">System</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A system object to store molecules for one&#39;s simulations.</span>

<span class="sd">    **Parameters**</span>
<span class="sd">    </span>
<span class="sd">        name: *str, optional*</span>
<span class="sd">            System Name.</span>
<span class="sd">        box_size: *tuple, float, optional*</span>
<span class="sd">            System x, y, and z lengths.</span>
<span class="sd">        box_angles: *tuple, float, optional*</span>
<span class="sd">            System xy, yz, and xz angles.</span>
<span class="sd">        periodic: *bool, optional*</span>
<span class="sd">            Whether to have periodic boundaries on or off.</span>

<span class="sd">    **Returns**</span>
<span class="sd">    </span>
<span class="sd">        system: :class:`structures.System`</span>
<span class="sd">            The System class container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize all system variables. Convert to float as necessary to prepare for any needed math</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">box_size</span><span class="o">=</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">),</span> <span class="n">box_angles</span><span class="o">=</span><span class="p">(</span><span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">),</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">box_size</span><span class="p">]</span>  <span class="c1"># (a, b, c)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">box_angles</span><span class="p">]</span>  <span class="c1"># (alpha, beta, gamma)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molecules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="n">periodic</span>

        <span class="c1"># If the system is not a monoclinic box, set lammps triclinic parameters</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">90</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setTriclinicBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span><span class="p">)</span>

        <span class="c1"># If system is a monoclinic box and set default lammps triclinic parameters</span>
        <span class="c1"># Assumes center of box is the origin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xlo</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ylo</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zlo</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zhi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xz</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yz</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Establish lammps triclinic box boundary conditions for this system</span>
<div class="viewcode-block" id="System.setTriclinicBox"><a class="viewcode-back" href="../codebase.html#structures.System.setTriclinicBox">[docs]</a>    <span class="k">def</span> <span class="nf">setTriclinicBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">box_angles</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to establish a triclinic box boundary condition for this system.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">        </span>
<span class="sd">            periodic: *bool, optional*</span>
<span class="sd">                Whether to have periodic boundaries on or off.</span>
<span class="sd">                Initial guess.</span>
<span class="sd">            box_size: *tuple, float, optional*</span>
<span class="sd">                System x, y, and z lengths.</span>
<span class="sd">            box_angles: *tuple, float, optional*</span>
<span class="sd">                System xy, yz, and xz angles.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># For lammmps, trigonal vectors established by using xy xz yz</span>
        <span class="c1"># A = (xhi-xlo,0,0);</span>
        <span class="c1"># B = (xy,yhi-ylo,0);</span>
        <span class="c1"># C = (xz,yz,zhi-zlo)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xlo</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ylo</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zlo</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Formula for converting (a,b,c,alpha,beta,gamma) to (lx,ly,lz,xy,xz,yz)</span>
        <span class="c1"># taken from online lammps help</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xhi</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xz</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yhi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yz</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xz</span><span class="p">)</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">yhi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zhi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xz</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">yz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="System.add"><a class="viewcode-back" href="../codebase.html#structures.System.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale_x</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scale_y</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scale_z</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to add a molecule to this system.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">        </span>
<span class="sd">            molecule: :class:`structures.Molecule`</span>
<span class="sd">                A Molecule structure.</span>
<span class="sd">            x: *float, optional*</span>
<span class="sd">                x offset to atomic positions of the input molecule.</span>
<span class="sd">            y: *float, optional*</span>
<span class="sd">                y offset to atomic positions of the input molecule.</span>
<span class="sd">            z: *float, optional*</span>
<span class="sd">                z offset to atomic positions of the input molecule.</span>
<span class="sd">            scale_x: *float, optional*</span>
<span class="sd">                scalar to offset x coordinates of the input molecule.</span>
<span class="sd">            scale_y: *float, optional*</span>
<span class="sd">                scalar to offset y coordinates of the input molecule.</span>
<span class="sd">            scale_z: *float, optional*</span>
<span class="sd">                scalar to offset z coordinates of the input molecule.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">new_atom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">new_atom</span><span class="o">.</span><span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="n">atom_offset</span>
            <span class="n">new_atom</span><span class="o">.</span><span class="n">x</span><span class="o">*=</span><span class="n">scale_x</span><span class="p">;</span> <span class="n">new_atom</span><span class="o">.</span><span class="n">y</span><span class="o">*=</span><span class="n">scale_y</span><span class="p">;</span> <span class="n">new_atom</span><span class="o">.</span><span class="n">z</span><span class="o">*=</span><span class="n">scale_z</span>
            <span class="n">new_atom</span><span class="o">.</span><span class="n">x</span><span class="o">+=</span><span class="n">x</span><span class="p">;</span> <span class="n">new_atom</span><span class="o">.</span><span class="n">y</span><span class="o">+=</span><span class="n">y</span><span class="p">;</span> <span class="n">new_atom</span><span class="o">.</span><span class="n">z</span><span class="o">+=</span><span class="n">z</span>
            <span class="n">new_atom</span><span class="o">.</span><span class="n">molecule_index</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">new_atom</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Bond</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="n">atom_offset</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">atoms</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Angle</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="n">atom_offset</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">atoms</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Dihedral</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="n">atom_offset</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">atoms</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">new_molecule</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">):]</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">):]</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">angles</span><span class="p">):]</span>
        <span class="n">new_molecule</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">):]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">new_molecule</span> <span class="p">)</span></div>
    
<div class="viewcode-block" id="System.Remove"><a class="viewcode-back" href="../codebase.html#structures.System.Remove">[docs]</a>    <span class="k">def</span> <span class="nf">Remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If target is a molecule, removes all atoms, bonds angles and dihedrals of</span>
<span class="sd">        the passed molecule from the system. Raises a ValueError if not all aspects</span>
<span class="sd">        of molecule are found in the system.</span>
<span class="sd">        </span>
<span class="sd">        If target is an Atom, the atom is removed from the system, and any bonds,</span>
<span class="sd">        angles, and dihedrals which contain the atom are also removed from the system.</span>
<span class="sd">        Raises a ValueError if the Atom is not found in the system.</span>

<span class="sd">        **Parameters**</span>
<span class="sd">        </span>
<span class="sd">            target: :class:`structures.Atom` *or* :class:`structures.Molecule`</span>
<span class="sd">                A target atom or molecule to be removed from this system. Target is a valid</span>
<span class="sd">                :class:`structures.Molecule` instance or a valid :class:`structures.Atom` instance.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Make sure all atoms in molecule are in system.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">Molecule</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
                        <span class="c1">#Check from the back of the atomlist, because the atom</span>
                        <span class="c1">#to be removed was also likely the last one added.</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">atomCheck</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Physical instance &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; wasn&#39;t found&quot;</span><span class="o">+</span>
                                         <span class="s2">&quot;in the given system.&quot;</span><span class="p">)</span>
            
            <span class="c1">#Repeat above for bonds, angles, dihedrals</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                    <span class="n">bondCheck</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                            <span class="n">bondCheck</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">bondCheck</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Physical instance &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; wasn&#39;t found&quot;</span><span class="o">+</span>
                                         <span class="s2">&quot;in the given system.&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
                    <span class="n">angleCheck</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                            <span class="n">angleCheck</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">angleCheck</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Physical instance &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; wasn&#39;t found&quot;</span><span class="o">+</span>
                                         <span class="s2">&quot;in the given system.&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                    <span class="n">dihedralCheck</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                            <span class="n">dihedralCheck</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dihedralCheck</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Physical instance &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; wasn&#39;t found&quot;</span><span class="o">+</span>
                                         <span class="s2">&quot;in the given system.&quot;</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                    <span class="k">break</span>
        
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">Atom</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
                <span class="c1">#Check from the back of the atomlist, because the atom</span>
                <span class="c1">#to be removed was also likely the last one added.</span>
                <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atomCheck</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_Physical instance &quot;</span><span class="o">+</span><span class="nb">repr</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; wasn&#39;t found&quot;</span><span class="o">+</span>
                                     <span class="s2">&quot;in the given system.&quot;</span><span class="p">)</span>

            <span class="c1"># Correct indices for all atoms after the deleted atom</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">delList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">newList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="c1">#If a bond has the target atom, mark it</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">delList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="c1">#Delete all of the bonds that were marked, from the end of the list</span>
            <span class="c1">#to the front so as to preserve order</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">delList</span><span class="p">:</span>
                    <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="o">=</span><span class="n">newList</span>

            <span class="n">delList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">newList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">delList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">delList</span><span class="p">:</span>
                    <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="o">=</span><span class="n">newList</span>

            <span class="n">delList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">newList</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                        <span class="n">delList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">delList</span><span class="p">:</span>
                    <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="o">=</span><span class="n">newList</span></div>

<div class="viewcode-block" id="System.Contains"><a class="viewcode-back" href="../codebase.html#structures.System.Contains">[docs]</a>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">molecule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if this system contains a molecule, based on the atoms, bonds, angles and dihedrals.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            molecule: :class:`structures.Molecule`</span>
<span class="sd">                A molecule to be checked if it resides within this system.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            is_contained: *bool*</span>
<span class="sd">                A boolean specifying if the molecule passed to this function is contained</span>
<span class="sd">                within this System object.  This implies that all atoms, bonds, angles,</span>
<span class="sd">                and dihedrals within the molecule are present in a molecule within the system.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Make sure all atoms in molecule are in system.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">atomCheck</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">atomCheck</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        
        <span class="c1">#Repeat above for bonds, angles, dihedrals</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">bondCheck</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">bondCheck</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bondCheck</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
                <span class="n">angleCheck</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">angleCheck</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">angleCheck</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                <span class="n">dihedralCheck</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                        <span class="n">dihedralCheck</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dihedralCheck</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#If python gets here, all aspects of molecule are in system.</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="System.remove_atom_index"><a class="viewcode-back" href="../codebase.html#structures.System.remove_atom_index">[docs]</a>    <span class="k">def</span> <span class="nf">remove_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes selected indices from system. Does so by compiling new lists for atoms, bonds, angles, and dihedrals. Will be faster than Remove in cases</span>
<span class="sd">        where you are only keeping a few atoms.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            type_indices: *list, int, optional*</span>
<span class="sd">                A list of OPLS types.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">_remove_atom_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="System.remove_atom_type"><a class="viewcode-back" href="../codebase.html#structures.System.remove_atom_type">[docs]</a>    <span class="k">def</span> <span class="nf">remove_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes selected OPLS types from system. Does so by compiling new lists for atoms, bonds, angles, and dihedrals. Will be faster than Remove in cases</span>
<span class="sd">        where you are only keeping a few atoms.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            type_indices: *list, int, optional*</span>
<span class="sd">                A list of OPLS types.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">_remove_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span> <span class="n">type_indices</span><span class="o">=</span><span class="n">type_indices</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="System.assign_molecules"><a class="viewcode-back" href="../codebase.html#structures.System.assign_molecules">[docs]</a>    <span class="k">def</span> <span class="nf">assign_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assigns a unique molecule index for each molecule and sets each atom.molecule_index to the appropriate index. The algorithm runs by recursively searching through every bonded atom and giving the same molecule index as the origin atom. Normally, this means that molecules that are not bonded to each other will have a unique molecule index. Specific elements can be assign a predetermined molecule index by passing a list of element lists.</span>

<span class="sd">        For example element_groups=[[6,8], [9]] will give all carbon and oxygen atoms a molecule index of 1 and fluorine atoms will have a molecule index of 2.</span>

<span class="sd">        It is possible to get different molecule indices within the same bonded compound by giving a specific &quot;bridging&quot; element a predetermined molecule index. This prevents the molecular index from spreading to the entire bonded structure.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            elements: *list, list, int, optional*</span>
<span class="sd">                A list of OPLS types.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning molecules&#39;</span><span class="p">)</span>

        <span class="c1"># Create a shorthand for the atoms in the system</span>
        <span class="n">atom_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>

        <span class="c1"># Reset molecule indices for all atoms to 0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">i_atom</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Add molecule numbering to different strands</span>
        <span class="c1"># Copper gets a molecule index of 1</span>
        <span class="c1"># BF4 gets a molecule index of 2</span>
        <span class="n">molecule_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_list</span><span class="p">):</span>
            <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

            <span class="c1"># Cycle elements list and assign predetermined molecules:</span>
            <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">elem_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="n">elem_group</span><span class="p">:</span>
                    <span class="n">i_atom</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Assign molecule index if it has not been assigned already</span>
            <span class="k">if</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">atom_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign_molecule_index</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">molecule_count</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">)</span>
                <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>
                <span class="n">molecule_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found and assigned </span><span class="si">%d</span><span class="s1"> molecules in system&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">molecule_count</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">atom_list</span></div>

<div class="viewcode-block" id="System.assign_molecule_index"><a class="viewcode-back" href="../codebase.html#structures.System.assign_molecule_index">[docs]</a>    <span class="k">def</span> <span class="nf">assign_molecule_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_list</span><span class="p">,</span> <span class="n">i_list_index</span><span class="p">,</span> <span class="n">molecule_count</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add molecule index to the atom if it has not already been assigned. Then recursively pass bonded atoms to the function</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            atom_list: *list*, :class:`structures.Molecule`</span>
<span class="sd">                A list of atoms</span>
<span class="sd">            i_list_index: *int*</span>
<span class="sd">                The index of the atom currently being assigned. Refers to atom_list index.</span>
<span class="sd">            molecule_count: *int*</span>
<span class="sd">                The index of the molecule to be assigned.</span>
<span class="sd">            elements: *list, list, int, optional*</span>
<span class="sd">                A list of OPLS types. Will be skipped during this part of the molecule assignment sequence.</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">i_list_index</span><span class="p">]</span>

        <span class="c1"># If element is in predefined molecule, skip assignment</span>
        <span class="k">for</span> <span class="n">offset</span><span class="p">,</span> <span class="n">elem_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">element</span> <span class="ow">in</span> <span class="n">elem_group</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">atom_list</span>

        <span class="c1"># If atom does not have a molecule index</span>
        <span class="k">if</span> <span class="n">i_atom</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i_atom</span><span class="o">.</span><span class="n">molecule_index</span> <span class="o">=</span> <span class="n">molecule_count</span>

            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">bondedAtom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_atom</span><span class="o">.</span><span class="n">bonded</span><span class="p">):</span>
                <span class="n">j_list_index</span> <span class="o">=</span> <span class="n">bondedAtom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">j_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">]</span>
                <span class="n">atom_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assign_molecule_index</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="n">j_list_index</span><span class="p">,</span> <span class="n">molecule_count</span><span class="p">,</span> <span class="n">elements</span><span class="o">=</span><span class="n">elements</span><span class="p">)</span>
                <span class="n">j_atom</span> <span class="o">=</span> <span class="n">atom_list</span><span class="p">[</span><span class="n">j_list_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">atom_list</span></div>

<div class="viewcode-block" id="System.set_types"><a class="viewcode-back" href="../codebase.html#structures.System.set_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given the atoms, bonds, angles, and dihedrals in a system object,</span>
<span class="sd">        generate a list of the unique atom, bond, angle, dihedral types</span>
<span class="sd">        and assign that to the system object.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            params: :class:`squid.ff_params.Parameters`, optional</span>
<span class="sd">                A parameters object holding all the possible parameters.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># unpack values from system</span>
        <span class="n">unpack</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">box_angles</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">box_angles</span><span class="p">,</span> <span class="n">run_name</span> <span class="o">=</span> <span class="n">unpack</span>
        <span class="c1"># unpack lammps box parameters from system</span>
        <span class="n">unpack</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xlo</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">ylo</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">zlo</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">xhi</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">yhi</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">zhi</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">xy</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">xz</span><span class="p">,</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">yz</span><span class="p">)</span>
        <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="n">zlo</span><span class="p">,</span> <span class="n">xhi</span><span class="p">,</span> <span class="n">yhi</span><span class="p">,</span> <span class="n">zhi</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xz</span><span class="p">,</span> <span class="n">yz</span> <span class="o">=</span> <span class="n">unpack</span>

        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ignore angles with no energy (~0 energy) or no typing information</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">ang</span> <span class="k">for</span> <span class="n">ang</span> <span class="ow">in</span> <span class="n">angles</span> <span class="k">if</span> <span class="n">ang</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ang</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">e</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ang</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">e</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="c1"># ignore dihedrals with no energy or no typing information.</span>
            <span class="n">dihedrals</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dihedrals</span> <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">e</span><span class="p">)]</span>

            <span class="c1"># get list of unique atom types</span>
            <span class="c1"># Note, the original implementation doesn&#39;t actually work.  So using a</span>
            <span class="c1"># naiive approach.  Due to issues with __eq__ and geometry.reduce_list</span>
            <span class="c1"># not working.</span>
            <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">xx</span><span class="p">):</span>
                <span class="n">yy</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yy</span><span class="p">:</span>
                        <span class="n">yy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">yy</span>

            <span class="n">atom_types_full</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
            <span class="n">bond_types_full</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">]</span>
            <span class="n">angle_types_full</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]</span>
            <span class="n">dihedral_types_full</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dihedrals</span><span class="p">]</span>

            <span class="n">atom_types</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">atom_types_full</span><span class="p">)</span>
            <span class="n">bond_types</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">bond_types_full</span><span class="p">)</span>
            <span class="n">angle_types</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">angle_types_full</span><span class="p">)</span>
            <span class="n">dihedral_types</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">dihedral_types_full</span><span class="p">)</span>

            <span class="n">at_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atom_types_full</span><span class="p">]</span>
            <span class="n">bt_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">bond_types_full</span><span class="p">]</span>
            <span class="n">ant_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">angle_types_full</span><span class="p">]</span>
            <span class="n">dt_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dihedral_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">dihedral_types_full</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">at_i</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">atom_types</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bonds</span><span class="p">,</span> <span class="n">bt_i</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">bond_types</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">ant_i</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">angle_types</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">,</span> <span class="n">dt_i</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">dihedral_types</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">atom_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span> <span class="o">=</span> <span class="n">atom_types</span><span class="p">,</span> <span class="n">bond_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span> <span class="o">=</span> <span class="n">angle_types</span><span class="p">,</span> <span class="n">dihedral_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span> <span class="o">=</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span>

            <span class="c1"># If we have mass info in our types, sort by mass, else don&#39;t sort</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># sort atom types by mass, largest masses first</span>
                <span class="n">atom_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">mass</span> <span class="o">+</span>
                                <span class="p">(</span><span class="o">-</span><span class="mf">1e6</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;reax&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># get type numbers to identify types to LAMMPS</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_types</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bond_types</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angle_types</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dihedral_types</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Step 1 - Get a list of all unique bonds, angles, and dihedrals and</span>
            <span class="c1"># assign this to atom_types, bond_types, angle_types, and dihedral_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">coul_type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom_lj_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">lj_type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dihedrals</span><span class="p">]))</span>

            <span class="c1"># To be consistent, we&#39;ll sort by atom indices.  Note, these are strings!</span>
            <span class="c1"># But they will be consistent for all things, so atom_coul_types would now</span>
            <span class="c1"># be guaranteed same order as atom_lj_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atom_lj_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

            <span class="c1"># Assign the lammps types to the actual types!</span>
            <span class="k">for</span> <span class="n">type_obj</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atom_lj_types</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">type_obj</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Step 2 - Ensure each type now is ordered via lammps output (1, 2, 3, 4...)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">coul_type</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">lammps_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">dump_pair_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lammps_command</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span><span class="p">:</span>
            <span class="n">lammps_command</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;set type </span><span class="si">%d</span><span class="s1"> charge </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">charge</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_lj_types</span><span class="p">:</span>
            <span class="n">lammps_command</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pair_coeff </span><span class="si">%d</span><span class="s1"> </span><span class="si">%d</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">lammps_type</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lammps_command</span><span class="p">)</span>

<div class="viewcode-block" id="System.packmol"><a class="viewcode-back" href="../codebase.html#structures.System.packmol">[docs]</a>    <span class="k">def</span> <span class="nf">packmol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecules</span><span class="p">,</span> <span class="n">new_method</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">molecule_ratio</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                <span class="n">density</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">persist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">custom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of molecules, pack this system appropriately.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">            molecules: *list,* :class:`structures.Molecule`</span>
<span class="sd">                Molecules to be added to this system.</span>
<span class="sd">            molecule_ratio: *tuple, float, optional*</span>
<span class="sd">                The ration that each molecule in *molecules* will be added to</span>
<span class="sd">                the system.</span>
<span class="sd">            density: *float, optional*</span>
<span class="sd">                The density of the system in g/mL</span>
<span class="sd">            seed: *float, optional*</span>
<span class="sd">                Seed for random generator.</span>
<span class="sd">            persist: *bool, optional*</span>
<span class="sd">                Whether to maintain the generated sys_packmol directory or</span>
<span class="sd">                not.</span>
<span class="sd">            number: *int or list, int, optional*</span>
<span class="sd">                Overide density and specify the exact number of molecules to</span>
<span class="sd">                pack. When using a list of molecules, you must specify each</span>
<span class="sd">                in order within a list.</span>
<span class="sd">            custom: *str, optional*</span>
<span class="sd">                A custom packmol script to run for the given input molecules.</span>
<span class="sd">                NOT YET IMPLEMENTED!</span>

<span class="sd">        **Returns**</span>

<span class="sd">            None</span>

<span class="sd">        **References**</span>

<span class="sd">            * Packmol - http://www.ime.unicamp.br/~martinez/packmol/home.shtml</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;sys_packmol&#39;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;sys_packmol&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s1">&#39;sys_packmol&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">custom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;THIS HAS NOT YET BEEN IMPLEMENTED!&quot;</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.packmol&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        tolerance 2.0</span>
<span class="s1">        filetype xyz</span>
<span class="s1">        output &#39;&#39;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&#39;&#39;.packed.xyz</span>
<span class="s1">        seed &#39;&#39;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &#39;&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># convert density to amu/angstrom^3. 1 g/mL = 0.6022 amu/angstrom^3</span>
        <span class="n">density</span> <span class="o">*=</span> <span class="mf">0.6022</span>
        <span class="n">average_molecular_weight</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">mass</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">new_method</span> <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">coul_type</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span> <span class="o">*</span>
             <span class="n">molecule_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">molecules</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">molecule_ratio</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">density</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span>
                 <span class="n">average_molecular_weight</span><span class="p">)</span>
        <span class="n">molecule_counts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">molecule_ratio</span><span class="p">)))</span>
                           <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">molecule_ratio</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">molecule_counts</span> <span class="o">=</span> <span class="n">number</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">molecule_counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">molecule_counts</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecules</span><span class="p">):</span>
            <span class="n">xyz_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">.xyz&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">xyz_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Atoms</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="n">xyz_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s%d</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="n">xyz_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        structure </span><span class="si">%d</span><span class="s1">.xyz</span>
<span class="s1">          number </span><span class="si">%d</span><span class="s1"></span>
<span class="s1">          inside box 0. 0. 0. </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"></span>
<span class="s1">        end structure</span>
<span class="s1">        &#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">molecule_counts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_size</span><span class="p">)))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">sysconst</span><span class="o">.</span><span class="n">packmol_path</span> <span class="o">+</span>
                  <span class="s1">&#39; &lt; &#39;</span> <span class="o">+</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                  <span class="s1">&#39;.packmol &gt; packmol.log&#39;</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">files</span><span class="o">.</span><span class="n">read_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.packed.xyz&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">)</span>

        <span class="c1"># Now have a list of atoms with element = H0 for molecule 0,</span>
        <span class="c1"># H1 for molecule 1, etc</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">molecule_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">molecules</span><span class="p">[</span><span class="n">molecule_number</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="c1"># Update positions of latest molecule</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">):]:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">persist</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;rm -rf sys_packmol&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="System.get_elements"><a class="viewcode-back" href="../codebase.html#structures.System.get_elements">[docs]</a>    <span class="k">def</span> <span class="nf">get_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This simplifies using dump_modify by getting a list of the elements in</span>
<span class="sd">        this system, sorted by their weight.  Note, duplicates will exist if</span>
<span class="sd">        different atom types exist within this system!</span>

<span class="sd">        **Returns**</span>

<span class="sd">            elements: *list, str*</span>
<span class="sd">                A list of the elements, sorted appropriately for something</span>
<span class="sd">                like dump_modify.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">atom_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">molec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">molecules</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molec</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_types</span><span class="p">:</span>
                        <span class="n">atom_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                        <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
            <span class="n">elem_mass</span> <span class="o">=</span> <span class="p">[</span><span class="n">units</span><span class="o">.</span><span class="n">elem_weight</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">elem_mass</span><span class="p">,</span> <span class="n">elems</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_types</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">element</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_coul_types</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="n">atom</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">text</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="n">atom</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">text</span></div>


<div class="viewcode-block" id="Struct"><a class="viewcode-back" href="../codebase.html#structures.Struct">[docs]</a><span class="k">class</span> <span class="nc">Struct</span><span class="p">(</span><span class="n">_Physical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generalized Structure object for python</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">])</span>
        <span class="p">)</span></div>


<span class="c1"># General atom manipulation functions</span>
<span class="c1"># Can be adapted by the structure objects as necessary</span>
<span class="c1"># ************************************************************************************</span>
<span class="k">def</span> <span class="nf">_remove_atom_index</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="p">[],</span> <span class="n">angles</span><span class="o">=</span><span class="p">[],</span> <span class="n">dihedrals</span><span class="o">=</span><span class="p">[],</span> <span class="n">indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes selected indices from the atoms, bonds, angles, and dihedrals.</span>
<span class="sd">    Will be fastest in cases where you are only keeping a few atoms.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atoms</span>
<span class="sd">        bonds: *list,* :class:`structures.Bond` *, optional*</span>
<span class="sd">            A list of bonds</span>
<span class="sd">        angles: *list,* :class:`structures.Angle` *, optional*</span>
<span class="sd">            A list of angles</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral` *, optional*</span>
<span class="sd">            A list of dihedrals</span>
<span class="sd">        type_indices: *list, int, optional*</span>
<span class="sd">            A list of atom indices.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            Updated list of atoms</span>
<span class="sd">        bonds: *list,* :class:`structures.Bond` *, optional*</span>
<span class="sd">            Updated list of bonds</span>
<span class="sd">        angles: *list,* :class:`structures.Angle` *, optional*</span>
<span class="sd">            Updated list of angles</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral` *, optional*</span>
<span class="sd">            Updated list of dihedrals</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Refresh the atoms stored in atoms, bonds, angles, dihedrals</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">)):</span>
            <span class="n">bond_atom</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">bond_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="c1"># Select atoms to keep</span>
    <span class="n">new_atoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)):</span>
        <span class="c1">#Check from the back of the atomlist, because the atom</span>
        <span class="c1">#to be removed was also likely the last one added.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                <span class="c1">#del atoms[len(atoms)-a-1]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_atoms</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial atoms: </span><span class="si">%d</span><span class="s1">, Removed atoms: </span><span class="si">%d</span><span class="s1">, Final atoms: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)))</span>

    <span class="c1"># Reset atoms to have the correct index</span>
    <span class="n">initial_index</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">):</span>
        <span class="n">new_atoms</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">initial_index</span> <span class="o">+</span> <span class="n">num</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_bonds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del bonds[len(bonds)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_bonds</span> <span class="o">=</span> <span class="n">new_bonds</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial bonds: </span><span class="si">%d</span><span class="s1">, Removed bonds: </span><span class="si">%d</span><span class="s1">, Final bonds: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_bonds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bonds</span><span class="p">)))</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_angles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del angles[len(angles)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_angles</span> <span class="o">=</span> <span class="n">new_angles</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial angles: </span><span class="si">%d</span><span class="s1">, Removed angles: </span><span class="si">%d</span><span class="s1">, Final angles: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">)))</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del dihedrals[len(dihedrals)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_dihedrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="n">new_dihedrals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial dihedrals: </span><span class="si">%d</span><span class="s1">, Removed dihedrals: </span><span class="si">%d</span><span class="s1">, Final dihedrals: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">new_atoms</span><span class="p">,</span> <span class="n">new_bonds</span><span class="p">,</span> <span class="n">new_angles</span><span class="p">,</span> <span class="n">new_dihedrals</span>

<span class="k">def</span> <span class="nf">_remove_atom_type</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="p">[],</span> <span class="n">angles</span><span class="o">=</span><span class="p">[],</span> <span class="n">dihedrals</span><span class="o">=</span><span class="p">[],</span> <span class="n">type_indices</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes selected OPLS types from system. Does so by compiling new lists for atoms, bonds, angles, and dihedrals. </span>
<span class="sd">    Will be fastest in cases where you are only keeping a few atoms.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            A list of atoms</span>
<span class="sd">        bonds: *list,* :class:`structures.Bond` *, optional*</span>
<span class="sd">            A list of bonds</span>
<span class="sd">        angles: *list,* :class:`structures.Angle` *, optional*</span>
<span class="sd">            A list of angles</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral` *, optional*</span>
<span class="sd">            A list of dihedrals</span>
<span class="sd">        type_indices: *list, int, optional*</span>
<span class="sd">            A list of atom indices.</span>

<span class="sd">    **Returns**</span>

<span class="sd">        atoms: *list,* :class:`structures.Atom`</span>
<span class="sd">            Updated list of atoms</span>
<span class="sd">        bonds: *list,* :class:`structures.Bond` *, optional*</span>
<span class="sd">            Updated list of bonds</span>
<span class="sd">        angles: *list,* :class:`structures.Angle` *, optional*</span>
<span class="sd">            Updated list of angles</span>
<span class="sd">        dihedrals: *list,* :class:`structures.Dihedral` *, optional*</span>
<span class="sd">            Updated list of dihedrals</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Refresh the atoms stored in atoms, bonds, angles, dihedrals</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">)):</span>
            <span class="n">bond_atom</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">atoms</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">bonded</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">bond_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">bonds</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">angles</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)):</span>
        <span class="n">new_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)):</span>
            <span class="n">temp_atom</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="n">new_atoms</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">temp_atom</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">dihedrals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)</span>

    <span class="n">new_atoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)):</span>
        <span class="c1">#Check from the back of the atomlist, because the atom</span>
        <span class="c1">#to be removed was also likely the last one added.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">type_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                <span class="c1">#del atoms[len(atoms)-a-1]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_atoms</span> <span class="o">=</span> <span class="n">new_atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial atoms: </span><span class="si">%d</span><span class="s1">, Removed atoms: </span><span class="si">%d</span><span class="s1">, Final atoms: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">)))</span>

    <span class="c1"># Reset atoms to have the correct index</span>
    <span class="n">initial_index</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
    <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_atoms</span><span class="p">):</span>
        <span class="n">new_atoms</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">initial_index</span> <span class="o">+</span> <span class="n">num</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_bonds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">type_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">type_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del bonds[len(bonds)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bonds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_bonds</span> <span class="o">=</span> <span class="n">new_bonds</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial bonds: </span><span class="si">%d</span><span class="s1">, Removed bonds: </span><span class="si">%d</span><span class="s1">, Final bonds: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_bonds</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bonds</span><span class="p">)))</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_angles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">type_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">type_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del angles[len(angles)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_angles</span> <span class="o">=</span> <span class="n">new_angles</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial angles: </span><span class="si">%d</span><span class="s1">, Removed angles: </span><span class="si">%d</span><span class="s1">, Final angles: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">)))</span>

    <span class="c1">#Make sure all atoms in molecule are in system.</span>
    <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)):</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">type_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">type_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="c1">#del dihedrals[len(dihedrals)-a-1]</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">new_dihedrals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="n">new_dihedrals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial dihedrals: </span><span class="si">%d</span><span class="s1">, Removed dihedrals: </span><span class="si">%d</span><span class="s1">, Final dihedrals: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">new_atoms</span><span class="p">,</span> <span class="n">new_bonds</span><span class="p">,</span> <span class="n">new_angles</span><span class="p">,</span> <span class="n">new_dihedrals</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../squid.html">Squid</a></li>
<li class="toctree-l1"><a class="reference internal" href="../codebase.html">Codebase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Squid 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Henry Herbol.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.6.
    </div>
  </body>
</html>